{"id":"gdoc-2id","content_hash":"7e4eb543ffa288420538482f930ea2198735c3600d3963f5c7692595b7a79220","title":"Implement cache management with --clear-cache flag","description":"Implement dual-cache system for extension_api.json at ~/.cache/gdoc/ with binary parsed cache for fast loading.","design":"## Cache Location\n- Use `known-folders` library to get cache directory\n- Cache files in `~/.cache/gdoc/`:\n  - `extension_api.json` - Raw JSON from Godot (source of truth)\n  - `extension_api.parsed` - Binary serialized parsed struct\n\n## Binary Cache Format\n```\n[0-3]   Magic \"GDOC\"\n[4-7]   Version (u32) - bump when struct layout changes\n[8-11]  Checksum/hash of JSON source (u32) - detect if JSON changed\n[12+]   Struct data dump\n```\n\n## Cache Flow\n**Normal run** (`gdoc Node2D`):\n1. Check if `.parsed` exists + valid (magic/version/checksum) → deserialize and use\n2. If `.parsed` invalid/missing, check if `extension_api.json` exists → parse it, create `.parsed`\n3. If JSON also missing → run `godot --dump-extension-api-with-docs`, save JSON, parse, create `.parsed`\n4. Only error if `godot` command not found or fails\n\n**With --clear-cache flag** (`gdoc Node2D --clear-cache`):\n1. Delete `~/.cache/gdoc/extension_api.json`\n2. Delete `~/.cache/gdoc/extension_api.parsed`\n3. Continue with normal lookup (triggers regeneration)\n4. Show \"Cache cleared, regenerating...\" message\n\n## Implementation Tasks\n- Add `known-folders` dependency to build.zig.zon\n- Implement getCacheDir() using known-folders\n- Implement binary cache format with magic header + version + checksum\n- Implement cache validation logic\n- Implement Godot execution: `godot --dump-extension-api-with-docs`\n- Implement atomic file writes (temp + rename)\n- Add --clear-cache flag handling","acceptance_criteria":"- [ ] Cache directory created at correct XDG location using known-folders\n- [ ] `extension_api.json` generated from Godot on first run if missing\n- [ ] Binary `.parsed` cache created with magic header + version + checksum\n- [ ] Cache validation detects stale/invalid cache and regenerates\n- [ ] `--clear-cache` flag deletes both cache files and regenerates\n- [ ] Errors gracefully when Godot not found and cache missing","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-11-14T16:06:33.344779+11:00","updated_at":"2025-11-15T23:43:10.06081183+11:00","closed_at":"2025-11-15T23:43:10.06081183+11:00","source_repo":"."}
{"id":"gdoc-42o","content_hash":"06717dc1f1631502592bbce0dac892189fd8ad37e94b6cb07151ea3e21a51027","title":"Tab completion support for shell environments","description":"Provide shell tab completion for symbol names across Bash, Zsh, Fish, and Nushell. Enable completing class names, methods, and properties interactively.","design":"## Overview\n\nEnable tab completion for gdoc symbols in multiple shells:\n- `gdoc Node\u003cTAB\u003e` → suggests `Node`, `Node2D`, `Node3D`, `NodePath`\n- `gdoc Node2D.\u003cTAB\u003e` → suggests `position`, `rotation`, `scale`, etc.\n- `gdoc Packed\u003cTAB\u003e` → suggests `PackedVectorArray`, `PackedByteArray`, etc.\n\n## Architecture\n\n**Completion Command**:\n```bash\ngdoc --complete \"Node\"\n# Outputs matching symbols (one per line):\n# Node\n# Node2D\n# Node3D\n# NodePath\n```\n\n**Shell Scripts**:\nEach shell gets a generated completion script that:\n1. Extracts current word/prefix from command line\n2. Calls `gdoc --complete \u003cprefix\u003e`\n3. Presents results to shell completion system\n\n## Shell Support\n\n1. **Bash** - Uses `complete` builtin with custom function\n2. **Zsh** - Uses `_gdoc` completion function\n3. **Fish** - Uses `complete -c gdoc` declarations\n4. **Nushell** - Uses custom completer in config.nu\n\n## Sub-issues\n\nThis epic tracks completion implementation across:\n1. Implement --complete flag (core functionality)\n2. Generate Bash completion script\n3. Generate Zsh completion script  \n4. Generate Fish completion script\n5. Add installation documentation\n\n## User Experience\n\n```bash\n# After installation\n$ source ~/.local/share/gdoc/completions/gdoc.bash  # Or add to .bashrc\n\n# Then use tab completion\n$ gdoc Pack\u003cTAB\u003e\nPackedByteArray  PackedColorArray  PackedFloat32Array  PackedVector2Array\n```","acceptance_criteria":"- [ ] --complete flag returns matching symbols for prefix\n- [ ] Bash completion script generated and works\n- [ ] Zsh completion script generated and works\n- [ ] Fish completion script generated and works\n- [ ] Documentation explains installation for each shell\n- [ ] Completes class names\n- [ ] Completes method/property names after dot notation","status":"open","priority":3,"issue_type":"epic","created_at":"2025-11-14T16:08:38.688464+11:00","updated_at":"2025-11-14T16:08:38.688464+11:00","source_repo":".","dependencies":[{"issue_id":"gdoc-42o","depends_on_id":"gdoc-zd9","type":"blocks","created_at":"2025-11-14T16:10:47.924334+11:00","created_by":"daemon"}]}
{"id":"gdoc-4xl","content_hash":"3a0017934722f28a02cdd66ecb145f4f77eb47848da4c1b92cb3f11f85b92a98","title":"Phase 3: Add class inheritance hierarchy support","description":"Parse the 'inherits' field from classes to show parent class relationships in documentation output.","design":"## Goal\n\nParse and display class inheritance hierarchy using the `inherits` field from extension_api.json.\n\n## JSON Structure\n\n```json\n{\n  \"name\": \"Node2D\",\n  \"inherits\": \"CanvasItem\",     // Parse this\n  \"api_type\": \"core\",\n  \"methods\": [...]\n}\n```\n\n## Expected Output\n\nWhen looking up a class, show its parent:\n\n```markdown\n# Node2D\n\n**Inherits**: CanvasItem\n\nA 2D scene object.\n\n## Description\n...\n```\n\n## Implementation Steps\n\n1. **Extend ClassKey enum:**\n```zig\nconst ClassKey = enum {\n    name,\n    methods,\n    properties,\n    signals,\n    constants,\n    enums,\n    description,\n    brief_description,\n    inherits,        // NEW\n};\n```\n\n2. **Store inherits during parsing:**\n```zig\nfn parseClass(...) {\n    var entry: Entry = ...;\n    var inherits_name: ?[]const u8 = null;\n    \n    while (...) {\n        switch (class_key) {\n            .inherits =\u003e {\n                inherits_name = try allocator.dupe(u8, try scanner.next().string);\n            }\n            // ... other cases\n        }\n    }\n    \n    // After storing the class entry, resolve inherits to parent_index\n    if (inherits_name) |parent_name| {\n        if (db.symbols.getIndex(parent_name)) |idx| {\n            entry_ptr.parent_index = idx;\n        }\n    }\n}\n```\n\n3. **Update generateMarkdownForEntry:**\n```zig\nfn generateMarkdownForEntry(...) {\n    try writer.print(\"# {s}\", .{entry.key});\n    \n    if (entry.signature) |sig| {\n        try writer.writeAll(sig);\n    }\n    \n    try writer.writeByte('\\n');\n    \n    // Show inheritance for classes\n    if (entry.kind == .class or entry.kind == .builtin_class) {\n        if (entry.parent_index) |parent_index| {\n            const parent = self.symbols.values()[parent_index];\n            try writer.print(\"\\n**Inherits**: {s}\\n\", .{parent.name});\n        }\n    }\n    \n    // Show parent for members (existing logic)\n    if (entry.kind == .method or entry.kind == .property or ...) {\n        if (entry.parent_index) |parent_index| {\n            const parent = self.symbols.values()[parent_index];\n            try writer.print(\"\\n**Parent**: {s}\\n\", .{parent.name});\n        }\n    }\n    \n    // ... rest of output\n}\n```\n\n## Handling Forward References\n\nClasses may reference parents that haven't been parsed yet. Two approaches:\n\n**Approach 1: Two-pass parsing**\n```zig\npub fn loadFromJsonLeaky(...) {\n    // First pass: parse all classes\n    for (classes) |class| {\n        parseClass(class, db);\n    }\n    \n    // Second pass: resolve inheritance\n    for (db.symbols.values()) |*entry| {\n        if (entry.inherits_name) |parent_name| {\n            entry.parent_index = db.symbols.getIndex(parent_name);\n        }\n    }\n}\n```\n\n**Approach 2: Store inherits_name temporarily**\n```zig\npub const Entry = struct {\n    key: []const u8,\n    name: []const u8,\n    parent_index: ?usize = null,\n    inherits_name: ?[]const u8 = null,  // Temporary, resolve later\n    // ...\n};\n```\n\nRecommend Approach 1 for cleaner separation.\n\n## Testing\n\n```zig\ntest \"class with inherits field\" {\n    const json = \\\\{\n      \"classes\": [\n        {\n          \"name\": \"CanvasItem\",\n          \"inherits\": \"Node\"\n        },\n        {\n          \"name\": \"Node2D\", \n          \"inherits\": \"CanvasItem\"\n        }\n      ]\n    }\n    \n    const db = try DocDatabase.loadFromJsonLeaky(allocator, \u0026scanner);\n    \n    const node2d = db.symbols.get(\"Node2D\").?;\n    try testing.expect(node2d.parent_index != null);\n    \n    const parent = db.symbols.values()[node2d.parent_index.?];\n    try testing.expectEqualStrings(\"CanvasItem\", parent.name);\n}\n```\n\n## Acceptance Criteria\n\n- [ ] Parse inherits field from classes\n- [ ] Resolve inherits to parent_index\n- [ ] Display \"Inherits: ParentClass\" for classes\n- [ ] Handle forward references correctly\n- [ ] Differentiate between class inheritance (Inherits) and member parent (Parent)\n- [ ] Unit tests verify inheritance resolution","status":"open","priority":3,"issue_type":"task","created_at":"2025-11-23T17:53:12.315927837+11:00","updated_at":"2025-11-23T17:53:12.315927837+11:00","source_repo":"."}
{"id":"gdoc-6v0","content_hash":"c88abb5041402007f08e3be6e6617905946e37d68501cde6b16494c109aad720","title":"Phase 1: Parse properties, signals, constants, and enums from JSON","description":"Parse the properties, signals, constants, and enums arrays from classes in extension_api.json. Add these member types to the Entry.members array alongside existing methods.","design":"## Goal\n\nParse all member type arrays from classes and add them to Entry.members:\n- `properties` array\n- `signals` array  \n- `constants` array\n- `enums` array\n\nCurrently only `methods` are being parsed.\n\n## JSON Structures to Parse\n\n### Property\n```json\n{\n  \"name\": \"position\",\n  \"type\": \"Vector2\",\n  \"setter\": \"set_position\",\n  \"getter\": \"get_position\",\n  \"description\": \"Position relative to parent.\"\n}\n```\n\n### Signal\n```json\n{\n  \"name\": \"body_entered\",\n  \"description\": \"Emitted when body enters.\",\n  \"arguments\": [\n    {\"name\": \"body\", \"type\": \"Node3D\"}\n  ]\n}\n```\n\n### Constant\n```json\n{\n  \"name\": \"NOTIFICATION_READY\",\n  \"value\": 30,\n  \"description\": \"Ready notification.\"\n}\n```\n\n### Enum\n```json\n{\n  \"name\": \"Mode\",\n  \"is_bitfield\": false,\n  \"values\": [\n    {\n      \"name\": \"MODE_ECB_ENCRYPT\",\n      \"value\": 0,\n      \"description\": \"AES ECB encryption mode.\"\n    }\n  ]\n}\n```\n\n## Implementation Steps\n\n1. **Extend ClassKey enum:**\n```zig\nconst ClassKey = enum {\n    name,\n    methods,\n    properties,     // NEW\n    signals,        // NEW\n    constants,      // NEW\n    enums,          // NEW\n    description,\n    brief_description,\n};\n```\n\n2. **Create parsing functions** (similar to parseMethod):\n```zig\nfn parseProperty(kind: EntryKind, allocator: Allocator, scanner: *Scanner) !Entry\nfn parseSignal(kind: EntryKind, allocator: Allocator, scanner: *Scanner) !Entry\nfn parseConstant(kind: EntryKind, allocator: Allocator, scanner: *Scanner) !Entry\nfn parseEnum(kind: EntryKind, allocator: Allocator, scanner: *Scanner) !Entry\n```\n\n3. **Update parseClass()** to collect all member types:\n```zig\nfn parseClass(...) {\n    var method_entries: ArrayList(Entry) = .empty;\n    var property_entries: ArrayList(Entry) = .empty;\n    var signal_entries: ArrayList(Entry) = .empty;\n    var constant_entries: ArrayList(Entry) = .empty;\n    var enum_entries: ArrayList(Entry) = .empty;\n    \n    // Parse each array when encountered\n    switch (class_key) {\n        .methods =\u003e // existing logic\n        .properties =\u003e // parse properties array\n        .signals =\u003e // parse signals array\n        .constants =\u003e // parse constants array\n        .enums =\u003e // parse enums array\n    }\n    \n    // Consolidate all into single members array\n    const total = method_entries.items.len + \n                  property_entries.items.len + \n                  signal_entries.items.len +\n                  constant_entries.items.len +\n                  enum_entries.items.len;\n    \n    var member_indices = try allocator.alloc(usize, total);\n    // Populate indices from all entry types\n}\n```\n\n4. **For each parsing function, extract:**\n- `name` → Entry.name\n- `description` → Entry.description (convert BBCode to Markdown)\n- Store with correct EntryKind (.property, .signal, .constant, .@\"enum\")\n\n## Testing\n\n```zig\ntest \"parse class with properties\" {\n    const json = \\\\{\n      \"classes\": [{\n        \"name\": \"Node2D\",\n        \"properties\": [\n          {\"name\": \"position\", \"type\": \"Vector2\"}\n        ]\n      }]\n    }\n    \n    const db = try DocDatabase.loadFromJsonLeaky(allocator, \u0026scanner);\n    const class_entry = db.symbols.get(\"Node2D\").?;\n    \n    // Verify members array includes property\n    try testing.expect(class_entry.members.?.len == 1);\n    \n    const property = db.symbols.values()[class_entry.members.?[0]];\n    try testing.expectEqualStrings(\"position\", property.name);\n    try testing.expectEqual(EntryKind.property, property.kind);\n}\n```\n\nSimilar tests for signals, constants, and enums.\n\n## Acceptance Criteria\n\n- [ ] Properties array is parsed from classes\n- [ ] Signals array is parsed from classes\n- [ ] Constants array is parsed from classes\n- [ ] Enums array is parsed from classes\n- [ ] All member types added to Entry.members alongside methods\n- [ ] Correct EntryKind assigned to each member type\n- [ ] BBCode descriptions converted to Markdown\n- [ ] Unit tests verify parsing for each member type","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-23T17:53:11.896559391+11:00","updated_at":"2025-11-23T17:53:11.896559391+11:00","source_repo":"."}
{"id":"gdoc-7dn","content_hash":"61ee0e01c08af17439de2a7999d626eabcb4b06a4f8a115fb35df148530be745","title":"Fix memory leak in parseClass method_entries ArrayList","description":"The method_entries ArrayList in parseClass is allocated but never freed, causing a memory leak that grows with the number of classes parsed.","design":"## Problem\n\nLine 119 in DocDatabase.zig:\n```zig\nvar method_entries: ArrayList(Entry) = .empty;\n```\n\nThe ArrayList is allocated and filled but `deinit()` is never called, leaking the internal buffer allocation.\n\n## Solution\n\nAdd defer statement after allocation:\n\n```zig\nvar method_entries: ArrayList(Entry) = .empty;\ndefer method_entries.deinit(allocator);\n```\n\n## Note\n\nThe function is marked as \"leaky\" (`loadFromJsonLeaky`) because it uses arena allocation for the parsed data, but the ArrayList's internal buffer is a separate allocation that should be freed.","acceptance_criteria":"- [ ] Add defer method_entries.deinit(allocator) after line 119\n- [ ] Verify no other ArrayList leaks exist\n- [ ] Tests pass without memory leaks","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-11-15T13:48:39.36352004+11:00","updated_at":"2025-11-23T00:14:35.742147574+11:00","closed_at":"2025-11-23T00:14:35.742147574+11:00","source_repo":"."}
{"id":"gdoc-7n6","content_hash":"b05b64de9160c2ffcdaa7d576e2ad2d29e9683a502319e790f079a9dcae10fb9","title":"Parse all Entry fields from extension_api.json","description":"Currently only parsing 3 out of 40+ available fields from extension_api.json. Missing entire member categories (properties, signals, constants, enums) and method signatures. This epic tracks implementing comprehensive JSON parsing across 3 phases: Phase 1 (gdoc-6v0), Phase 2 (gdoc-r48), Phase 3 (gdoc-4xl).","design":"## Current Parsing Status\n\n**Currently Parsed (3/40+ fields):**\n- `name` - Symbol name ✅\n- `brief_description` - Short description (BBCode → Markdown) ✅\n- `description` - Long description (BBCode → Markdown) ✅\n- `methods` array - Only method names, no signatures ⚠️\n\n**Missing Everything Else:**\n- Properties, signals, constants, enums (not parsed at all)\n- Method signatures (return_type, arguments)\n- Class inheritance hierarchy\n- Method modifiers (is_const, is_static, is_virtual)\n\n---\n\n## Complete JSON Structure from extension_api.json\n\n### Classes Array\n\n```json\n{\n  \"name\": \"Node2D\",\n  \"brief_description\": \"...\",         // [PARSED]\n  \"description\": \"...\",               // [PARSED]\n  \"inherits\": \"CanvasItem\",           // [MISSING] - for hierarchy\n  \"api_type\": \"core\",                 \n  \"is_instantiable\": true,\n  \n  \"methods\": [...],                   // [PARTIAL] - only names\n  \"properties\": [...],                // [MISSING] ⚠️\n  \"signals\": [...],                   // [MISSING] ⚠️\n  \"constants\": [...],                 // [MISSING] ⚠️\n  \"enums\": [...]                      // [MISSING] ⚠️\n}\n```\n\n### Method Objects\n\n```json\n{\n  \"name\": \"add_child\",\n  \"description\": \"Adds a child node...\",\n  \"return_value\": {                   // [MISSING] - for signature\n    \"type\": \"void\"\n  },\n  \"arguments\": [                      // [MISSING] - for signature\n    {\n      \"name\": \"node\",\n      \"type\": \"Node\",\n      \"default_value\": \"null\"\n    },\n    {\n      \"name\": \"force_readable_name\",\n      \"type\": \"bool\",\n      \"default_value\": \"false\"\n    }\n  ],\n  \"is_const\": false,                  // [MISSING] - method modifiers\n  \"is_static\": false,\n  \"is_virtual\": false,\n  \"is_vararg\": false\n}\n```\n\n### Property Objects\n\n```json\n{\n  \"name\": \"position\",                 // [MISSING] ⚠️\n  \"type\": \"Vector2\",                  // [MISSING] - for signature\n  \"setter\": \"set_position\",\n  \"getter\": \"get_position\",\n  \"description\": \"Position relative to parent.\"\n}\n```\n\n### Signal Objects\n\n```json\n{\n  \"name\": \"body_entered\",             // [MISSING] ⚠️\n  \"description\": \"Emitted when...\",\n  \"arguments\": [\n    {\n      \"name\": \"body\",\n      \"type\": \"Node3D\"\n    }\n  ]\n}\n```\n\n### Constant Objects\n\n```json\n{\n  \"name\": \"NOTIFICATION_READY\",       // [MISSING] ⚠️\n  \"value\": 30,                        // [MISSING] - for signature\n  \"description\": \"Ready notification.\"\n}\n```\n\n### Enum Objects\n\n```json\n{\n  \"name\": \"Mode\",                     // [MISSING] ⚠️\n  \"is_bitfield\": false,\n  \"values\": [\n    {\n      \"name\": \"MODE_ECB_ENCRYPT\",\n      \"value\": 0,\n      \"description\": \"AES ECB encryption mode.\"\n    }\n  ]\n}\n```\n\n### Utility Functions (global functions)\n\n```json\n{\n  \"name\": \"sin\",\n  \"return_type\": \"float\",             // [MISSING] - for signature\n  \"category\": \"math\",\n  \"arguments\": [\n    {\n      \"name\": \"angle_rad\",\n      \"type\": \"float\"\n    }\n  ],\n  \"description\": \"Returns sine...\",\n  \"is_vararg\": false\n}\n```\n\n---\n\n## Recommended Signature Formats\n\nThe `Entry.signature` field should contain:\n\n**Methods:**\n```zig\nsignature = \"(node: Node, force_readable_name: bool = false) -\u003e void\"\n```\n\n**Properties:**\n```zig\nsignature = \": Vector2\"\n```\n\n**Constants:**\n```zig\nsignature = \": int = 30\"\n```\n\n**Global Functions:**\n```zig\nsignature = \"(angle_rad: float) -\u003e float\"\n```\n\n**Signals:**\n```zig\nsignature = \"(body: Node3D)\"\n```\n\n**Enums:**\n```zig\nsignature = null  // or enum value count\n```\n\n---\n\n## Implementation Plan\n\n### Phase 1: Parse Properties, Signals, Constants, Enums\n\n1. **Extend `ClassKey` enum:**\n```zig\nconst ClassKey = enum {\n    name,\n    methods,\n    properties,     // NEW\n    signals,        // NEW\n    constants,      // NEW\n    enums,          // NEW\n    description,\n    brief_description,\n    inherits,       // NEW - for hierarchy\n};\n```\n\n2. **Create parsing functions:**\n- `parseProperty()` - similar to parseMethod\n- `parseSignal()` - parse signal with arguments\n- `parseConstant()` - parse constant with value\n- `parseEnum()` - parse enum with values\n\n3. **Update `parseClass()` to handle all member types:**\n```zig\nfn parseClass(...) {\n    var method_entries: ArrayList(Entry) = .empty;\n    var property_entries: ArrayList(Entry) = .empty;\n    var signal_entries: ArrayList(Entry) = .empty;\n    var constant_entries: ArrayList(Entry) = .empty;\n    var enum_entries: ArrayList(Entry) = .empty;\n    \n    // ... parse all arrays ...\n    \n    // Consolidate all into members array\n    const total_members = method_entries.items.len + \n                         property_entries.items.len + \n                         signal_entries.items.len +\n                         constant_entries.items.len +\n                         enum_entries.items.len;\n    \n    var member_indices = try allocator.alloc(usize, total_members);\n    // ... populate from all entry types ...\n}\n```\n\n### Phase 2: Build Method Signatures\n\n1. **Extend `MethodKey` enum:**\n```zig\nconst MethodKey = enum {\n    name,\n    return_value,   // NEW - or return_type for utility_functions\n    return_type,    // NEW - for utility_functions\n    arguments,      // NEW\n    description,    // NEW\n    is_const,       // NEW\n    is_static,      // NEW\n    is_vararg,      // NEW\n};\n```\n\n2. **Parse method arguments and return type:**\n```zig\nfn parseMethod(...) {\n    var method: Entry = ...;\n    var args_list: ArrayList(Argument) = .empty;\n    var return_type: ?[]const u8 = null;\n    \n    while (...) {\n        switch (method_key) {\n            .arguments =\u003e args_list = try parseArguments(...),\n            .return_value =\u003e return_type = try parseReturnValue(...),\n            .return_type =\u003e return_type = ...,  // for utility_functions\n            // ...\n        }\n    }\n    \n    // Build signature\n    method.signature = try buildMethodSignature(allocator, args_list, return_type);\n}\n```\n\n3. **Implement signature builders:**\n```zig\nfn buildMethodSignature(allocator: Allocator, args: []Argument, return_type: ?[]const u8) ![]const u8 {\n    // Format: \"(arg1: Type = default, arg2: Type) -\u003e ReturnType\"\n}\n\nfn buildPropertySignature(allocator: Allocator, type_name: []const u8) ![]const u8 {\n    // Format: \": Vector2\"\n}\n\nfn buildConstantSignature(allocator: Allocator, value: ?[]const u8) ![]const u8 {\n    // Format: \" = 30\" or \": int = 30\"\n}\n```\n\n### Phase 3: Add Inheritance Support\n\n1. **Parse `inherits` field in classes**\n2. **Store parent class name** (resolve to index later)\n3. **Display in output:** `**Inherits**: CanvasItem`\n\n---\n\n## Testing Strategy\n\n### Unit Tests\n\n1. **Test parseProperty:**\n```zig\ntest \"parse property with type\" {\n    const json = \\\\{\"name\": \"position\", \"type\": \"Vector2\"}\n    const property = try parseProperty(...);\n    try testing.expectEqualStrings(\"position\", property.name);\n    try testing.expectEqualStrings(\": Vector2\", property.signature.?);\n}\n```\n\n2. **Test parseMethod with signature:**\n```zig\ntest \"parse method with arguments and return\" {\n    const json = \\\\{\n      \"name\": \"add_child\",\n      \"return_value\": {\"type\": \"void\"},\n      \"arguments\": [{\"name\": \"node\", \"type\": \"Node\"}]\n    }\n    const method = try parseMethod(...);\n    try testing.expectEqualStrings(\"(node: Node) -\u003e void\", method.signature.?);\n}\n```\n\n3. **Test class with all member types:**\n```zig\ntest \"class with properties, methods, signals, constants\" {\n    // Parse full class JSON\n    // Verify all member types are in members array\n    // Verify correct kinds assigned\n}\n```\n\n### Integration Tests\n\nUpdate existing snapshot tests to verify complete parsing:\n- Properties appear in \"## Properties\" section\n- Signals appear in \"## Signals\" section  \n- Constants appear in \"## Constants\" section\n- Method signatures include parameters and return types\n\n---\n\n## Priority Fields\n\n### Must Have (Phase 1):\n1. ✅ Properties array → Entry.members\n2. ✅ Signals array → Entry.members\n3. ✅ Constants array → Entry.members\n4. ✅ Enums array → Entry.members\n5. ✅ Method return_value → Entry.signature\n6. ✅ Method arguments → Entry.signature\n\n### Should Have (Phase 2):\n7. Property type → Entry.signature\n8. Constant value → Entry.signature\n9. Signal arguments → Entry.signature\n10. Class inherits → show hierarchy\n11. Method is_const, is_static → signature modifiers\n\n### Nice to Have (Phase 3):\n12. Default argument values → show in signature\n13. is_vararg → mark variadic functions\n14. Enum values → show in documentation\n15. api_type → distinguish core/editor APIs","status":"open","priority":2,"issue_type":"bug","created_at":"2025-11-23T17:42:42.953776131+11:00","updated_at":"2025-11-23T17:53:25.417427521+11:00","source_repo":".","dependencies":[{"issue_id":"gdoc-7n6","depends_on_id":"gdoc-6v0","type":"blocks","created_at":"2025-11-23T17:56:55.198015306+11:00","created_by":"daemon"},{"issue_id":"gdoc-7n6","depends_on_id":"gdoc-r48","type":"blocks","created_at":"2025-11-23T17:56:55.207353697+11:00","created_by":"daemon"},{"issue_id":"gdoc-7n6","depends_on_id":"gdoc-4xl","type":"blocks","created_at":"2025-11-23T17:56:55.216625564+11:00","created_by":"daemon"}]}
{"id":"gdoc-8nh","content_hash":"22a938659716d98047d1753119a4640145bea80dc4eb29f9647c7f0e37c30447","title":"Fix panic on unknown JSON keys in parseClass","description":"The parser panics when encountering unknown JSON keys in class objects. This is fragile and will crash when Godot adds new fields to the API or when optional fields exist that weren't anticipated.","design":"## Problem\n\nLine 127 in DocDatabase.zig:\n```zig\nswitch (std.meta.stringToEnum(ClassKey, s) orelse std.debug.panic(\"Unexpected class key: {s}\", .{s})) {\n```\n\nThis panics on any unknown key, making the parser brittle to JSON schema evolution.\n\n## Solution\n\nReplace panic with `continue` to skip unknown keys gracefully:\n\n```zig\nswitch (std.meta.stringToEnum(ClassKey, s) orelse continue) {\n```\n\nThis allows forward compatibility with future Godot API versions that add new fields.\n\n## Testing\n\nAdd test case with unknown field to verify it's skipped without crashing.","acceptance_criteria":"- [ ] Replace panic with continue on line 127\n- [ ] Add test case with unknown JSON field\n- [ ] Test passes without crashing","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-11-15T13:48:39.208041346+11:00","updated_at":"2025-11-23T00:13:07.606014375+11:00","closed_at":"2025-11-23T00:13:07.606014375+11:00","source_repo":"."}
{"id":"gdoc-95w","content_hash":"10335ab258281d049d3947caf448374031a6431608a7a443d80aa4126a3cc2f1","title":"Implement cache flow decision logic","description":"Implement the cache loading flow: check parsed cache, fallback to JSON, fallback to generating from Godot.","design":"## Function Signature\n```zig\npub fn loadOrGenerateCache(allocator: Allocator, godot_path: []const u8) !CacheFile\n```\n\n## Cache Flow Logic\n\n**Step 1: Try to load parsed cache**\n```zig\nconst parsed_path = try getParsedCachePath(allocator);\ndefer allocator.free(parsed_path);\n\nif (CacheFile.loadFromPath(allocator, parsed_path)) |cache| {\n    // Success - return cached data\n    return cache;\n} else |err| {\n    // Parsed cache invalid or missing, continue to step 2\n}\n```\n\n**Step 2: Try to load JSON cache**\n```zig\nconst json_path = try getJsonCachePath(allocator);\ndefer allocator.free(json_path);\n\nconst json_data = std.fs.cwd().readFileAlloc(allocator, json_path, max_size) catch |err| {\n    // JSON missing, continue to step 3\n    // Generate from Godot\n    try generateApiJson(allocator, godot_path);\n    \n    // Now read the generated JSON\n    const generated_json = try std.fs.cwd().readFileAlloc(allocator, json_path, max_size);\n    defer allocator.free(generated_json);\n    \n    // Parse and cache it\n    return try parseAndCache(allocator, generated_json);\n};\ndefer allocator.free(json_data);\n\n// Parse JSON and create parsed cache\nreturn try parseAndCache(allocator, json_data);\n```\n\n**Step 3: Helper to parse and cache**\n```zig\nfn parseAndCache(allocator: Allocator, json_data: []const u8) !CacheFile {\n    // Parse JSON into data structure\n    const parsed_data = try parseExtensionApi(allocator, json_data);\n    \n    // Save to parsed cache\n    const cache_file = CacheFile{\n        .header = ...,\n        .data = parsed_data,\n    };\n    \n    const parsed_path = try getParsedCachePath(allocator);\n    defer allocator.free(parsed_path);\n    \n    try cache_file.saveToPath(parsed_path);\n    \n    return cache_file;\n}\n```\n\n## Error Handling\n\n- Return error if all steps fail (Godot not found, execution failed)\n- Invalid parsed cache → fallback silently\n- Missing JSON → generate automatically\n- Godot not found → return clear error message","acceptance_criteria":"- [ ] Loads parsed cache if valid\n- [ ] Falls back to JSON if parsed invalid/missing\n- [ ] Generates from Godot if JSON missing\n- [ ] Creates parsed cache after loading JSON\n- [ ] Returns error only if Godot unavailable and no cache\n- [ ] Validates parsed cache with verifyChecksum()\n- [ ] Handles all error cases gracefully","status":"in_progress","priority":1,"issue_type":"task","created_at":"2025-11-15T23:41:44.597445438+11:00","updated_at":"2025-11-16T14:52:58.717844232+11:00","source_repo":".","dependencies":[{"issue_id":"gdoc-95w","depends_on_id":"gdoc-2id","type":"blocks","created_at":"2025-11-15T23:41:44.598951784+11:00","created_by":"daemon"},{"issue_id":"gdoc-95w","depends_on_id":"gdoc-ejp","type":"blocks","created_at":"2025-11-15T23:41:44.599654242+11:00","created_by":"daemon"}]}
{"id":"gdoc-anz","content_hash":"8e4833b7cba235723c960b13ab02234b499450a4ff359820aa68718392e1b65b","title":"Implement display formatting for classes and members","description":"Display documentation in terminal with formatting similar to zigdoc. Show class info with member listings, or detailed member info when looking up specific members.","design":"## Output Format\n\n**Markdown-based output** consistent with existing snapshots, renders well in terminals.\n\n### Simple Member (Property/Method)\n```markdown\n# Node2D.position\n\n**Parent**: Node2D\n\nPosition, relative to the node's parent.\n\n## Description\n\nPosition, relative to the node's parent.\n```\n\n### Global Function\n```markdown\n# sin(angle: float) -\u003e float\n\n## Description\n\nReturns the sine of angle in radians.\n```\n\n### Class with Members\n```markdown\n# Node\n\nBase class for all scene objects.\n\n## Description\n\nNode is the base class for all scene objects. Nodes can be organized in a tree structure...\n\n## Properties\n- **name: StringName** - The node's name\n- **owner: Node** - The node's owner\n- **position: Vector2**\n\n## Methods\n- **add_child(node: Node, force_readable_name: bool)** - Adds a child node\n- **get_parent() -\u003e Node** - Returns the parent node\n- **queue_free()**\n\n## Signals\n- **ready()** - Emitted when the node is ready\n- **tree_entered()** - Emitted when entering the scene tree\n\n## Constants\n- **NOTIFICATION_READY: int** - Ready notification\n- **PROCESS_MODE_INHERIT: int**\n\n## Enums\n- **ProcessMode** - How the node processes\n- **DuplicateFlags** - Flags for duplication\n```\n\n## Implementation Approach\n\n**Extend existing `generateMarkdownForEntry()`** in `DocDatabase.zig`.\n\n### Current State\n- `generateMarkdownForEntry()` handles title, parent, brief, description\n- `Entry.members` array of member indices exists\n- BBCode to Markdown conversion working\n\n### What to Add\n\n**New function `generateMemberListings()`:**\n```zig\nfn generateMarkdownForEntry(self: DocDatabase, entry: Entry, writer: *Writer) !void {\n    // Existing: title with signature if function/method\n    if (entry.signature) |sig| {\n        try writer.print(\"# {s}{s}\\n\", .{entry.name, sig});\n    } else {\n        try writer.print(\"# {s}\\n\", .{entry.key});\n    }\n    \n    if (entry.parent_index) |parent_index| { /* ... */ }\n    if (entry.brief_description) |brief| { /* ... */ }\n    if (entry.description) |desc| { /* ... */ }\n    \n    // NEW: Member listings for classes\n    if (entry.members) |member_indices| {\n        try self.generateMemberListings(member_indices, writer);\n    }\n}\n\nfn generateMemberListings(self: DocDatabase, member_indices: []usize, writer: *Writer) !void {\n    const allocator = self.symbols.allocator;\n    \n    // Group by kind\n    var properties = ArrayList(usize).init(allocator);\n    var methods = ArrayList(usize).init(allocator);\n    var signals = ArrayList(usize).init(allocator);\n    var constants = ArrayList(usize).init(allocator);\n    var enums = ArrayList(usize).init(allocator);\n    defer properties.deinit();\n    defer methods.deinit();\n    defer signals.deinit();\n    defer constants.deinit();\n    defer enums.deinit();\n    \n    // Classify members\n    for (member_indices) |idx| {\n        const member = self.symbols.values()[idx];\n        switch (member.kind) {\n            .property =\u003e try properties.append(idx),\n            .method =\u003e try methods.append(idx),\n            .signal =\u003e try signals.append(idx),\n            .constant =\u003e try constants.append(idx),\n            .enum =\u003e try enums.append(idx),\n            else =\u003e {},\n        }\n    }\n    \n    // Output sections (skip if empty)\n    if (properties.items.len \u003e 0) {\n        try writer.print(\"\\n## Properties\\n\", .{});\n        for (properties.items) |idx| {\n            try self.formatMemberLine(idx, writer);\n        }\n    }\n    \n    if (methods.items.len \u003e 0) {\n        try writer.print(\"\\n## Methods\\n\", .{});\n        for (methods.items) |idx| {\n            try self.formatMemberLine(idx, writer);\n        }\n    }\n    \n    if (signals.items.len \u003e 0) {\n        try writer.print(\"\\n## Signals\\n\", .{});\n        for (signals.items) |idx| {\n            try self.formatMemberLine(idx, writer);\n        }\n    }\n    \n    if (constants.items.len \u003e 0) {\n        try writer.print(\"\\n## Constants\\n\", .{});\n        for (constants.items) |idx| {\n            try self.formatMemberLine(idx, writer);\n        }\n    }\n    \n    if (enums.items.len \u003e 0) {\n        try writer.print(\"\\n## Enums\\n\", .{});\n        for (enums.items) |idx| {\n            try self.formatMemberLine(idx, writer);\n        }\n    }\n}\n\nfn formatMemberLine(self: DocDatabase, member_idx: usize, writer: *Writer) !void {\n    const member = self.symbols.values()[member_idx];\n    \n    try writer.print(\"- **{s}\", .{member.name});\n    \n    // Add signature/type if available\n    if (member.signature) |sig| {\n        try writer.print(\"{s}\", .{sig}); // Already includes parens/type info\n    }\n    \n    try writer.print(\"**\");\n    \n    // Add brief description if available\n    if (member.brief_description) |brief| {\n        try writer.print(\" - {s}\", .{brief});\n    }\n    \n    try writer.print(\"\\n\", .{});\n}\n```\n\n## Member Line Formatting Rules\n\n**Properties:** `- **name: Type** - Brief` or `- **name: Type**` or `- **name**`\n\n**Methods:** `- **name(params) -\u003e ReturnType** - Brief` or `- **name(params)**` or `- **name**`\n\n**Signals:** `- **signal_name(params)** - Brief` or `- **signal_name()**`\n\n**Constants:** `- **NAME: Type** - Brief` or `- **NAME: Type**` or `- **NAME**`\n\n**Enums:** `- **EnumName** - Brief` or `- **EnumName**`\n\nPriority: Show signature/type + brief \u003e signature/type only \u003e name only\n\n## Testing Strategy\n\n**Snapshot tests** following existing pattern:\n\n1. **`snapshots/class_with_members.md`** - Full class with all member types\n2. **`snapshots/class_without_brief.md`** - Members without brief_description\n3. **`snapshots/method_with_signature.md`** - Method with full signature\n4. **`snapshots/global_function_with_signature.md`** - Global function with signature\n\n```zig\ntest \"generateMarkdownForSymbol for class with members\" {\n    const allocator = std.testing.allocator;\n    \n    var db = DocDatabase{ .symbols = StringArrayHashMap(Entry).empty };\n    defer db.symbols.deinit(allocator);\n    \n    // Create parent class with members array\n    const class_entry = Entry{\n        .key = \"Node2D\",\n        .name = \"Node2D\",\n        .kind = .class,\n        .brief_description = \"2D scene node\",\n        .description = \"Base class for 2D objects...\",\n        .members = \u0026[_]usize{1, 2, 3},\n    };\n    try db.symbols.put(allocator, \"Node2D\", class_entry);\n    \n    // Create member entries (property, method, constant)\n    // Add to db.symbols...\n    \n    // Generate and write snapshot\n    var file = try std.fs.cwd().createFile(\"snapshots/class_with_members.md\", .{});\n    defer file.close();\n    \n    try db.generateMarkdownForSymbol(\"Node2D\", \u0026file.writer());\n}","acceptance_criteria":"- [ ] Class lookup displays name, category, inheritance, description\n- [ ] Class lookup lists all members grouped by kind (properties, methods, constants)\n- [ ] Property lookup shows parent, type, description\n- [ ] Method lookup shows parent, signature, description\n- [ ] Output matches zigdoc-style formatting\n- [ ] Symbol not found shows clear error message\n- [ ] Markdown descriptions display correctly in terminal","notes":"## Implementation Complete ✅\n\nSuccessfully implemented display formatting for classes with members using TDPP.\n\n### What Was Implemented\n\n1. **`generateMemberListings()`** - Groups members by kind (properties, methods, signals, constants, enums)\n2. **`formatMemberSection()`** - Outputs section header and iterates through members\n3. **`formatMemberLine()`** - Formats individual member lines with signature and brief description\n4. **Integration** - Extended `generateMarkdownForEntry()` to call member listings when present\n5. **Signature in title** - Methods and functions now display signatures in the title\n\n### Snapshot Tests - Complete: 4/4 ✅\n\n✅ `snapshots/class_with_members.md` - Full class with properties, methods, and constants\n✅ `snapshots/class_without_brief.md` - Members without brief_description\n✅ `snapshots/method_with_signature.md` - Method with full signature in title\n✅ `snapshots/global_function_with_signature.md` - Global function with signature in title\n\n### Known Issues Discovered\n\nAlthough all Entry fields exist, not all are parsed from JSON:\n- Missing parsing for some fields in JSON parsing logic\n- This needs to be addressed in a follow-up issue","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-11-14T16:07:45.729809+11:00","updated_at":"2025-11-23T17:42:20.436868555+11:00","closed_at":"2025-11-23T17:42:20.360752269+11:00","source_repo":".","dependencies":[{"issue_id":"gdoc-anz","depends_on_id":"gdoc-mqq","type":"blocks","created_at":"2025-11-14T16:10:47.632177+11:00","created_by":"daemon"}]}
{"id":"gdoc-asn","content_hash":"8a9b02d81d4644e952ee2eb31151c92708921c619d9c42e0c29e4e0c3f16282b","title":"Verify @GlobalScope prefix handling with real Godot API JSON","description":"The acceptance criteria states that global functions should strip @GlobalScope prefix, but the implementation doesn't do this. Need to verify with real Godot extension_api.json whether utility_functions include this prefix or not.","design":"## Investigation Needed\n\nDownload actual Godot extension_api.json and check:\n1. Do utility_functions entries have names like \"@GlobalScope.sin\" or just \"sin\"?\n2. Are there any other places where @GlobalScope prefix appears?\n\n## Possible Outcomes\n\n**If prefix exists in JSON:**\n- Add stripping logic: `if (std.mem.startsWith(u8, name, \"@GlobalScope.\")) name = name[\"@GlobalScope.\".len..];`\n\n**If prefix doesn't exist:**\n- Document that JSON doesn't include prefix\n- Update acceptance criteria understanding\n\n## Testing\n\nUse real extension_api.json from Godot 4.x in test suite.","acceptance_criteria":"- [ ] Download real Godot extension_api.json\n- [ ] Verify utility_functions name format\n- [ ] Add stripping logic if needed OR document why it's not needed\n- [ ] Add test with real JSON sample","status":"closed","priority":2,"issue_type":"task","created_at":"2025-11-15T13:48:39.440664701+11:00","updated_at":"2025-11-23T00:17:10.96655606+11:00","closed_at":"2025-11-23T00:17:10.96655606+11:00","source_repo":"."}
{"id":"gdoc-blf","content_hash":"ad4535e4685e25b52805f55fdc42fc713a2fa1af3c0ea90ffecbfb2c13ae1e2e","title":"Add terminal-formatted output with zigdown renderer","description":"Add `--output-format` CLI flag to support both plain markdown and terminal-formatted output using the zigdown library.\n\n## Overview\nSupport two output formats:\n- `markdown`: Plain markdown text (current behavior)\n- `terminal`: Rich terminal formatting using zigdown (colors, wrapping, styling)\n\nDefault behavior: Auto-detect based on TTY (terminal format for interactive sessions, markdown for pipes/redirects)\n\n## CLI Interface\n\n### New Flag\n- Name: `--output-format`\n- Type: String enum with values `\"markdown\"` | `\"terminal\"`\n- Default: Auto-detected via `std.io.getStdOut().isTty()`\n- Description: \"Output format (markdown or terminal). Defaults to terminal for TTY, markdown otherwise.\"\n\n### Flag Implementation (src/cli/root.zig)\n```zig\ntry root.addFlag(.{\n    .name = \"output-format\",\n    .description = \"Output format (markdown or terminal)\",\n    .type = .String,\n    .default_value = .{ .String = \"\" }, // Empty means auto-detect\n});\n```\n\n### Format Detection in runLookup\n```zig\nconst format_flag = ctx.flag(\"output-format\", []const u8);\nconst format: OutputFormat = if (format_flag.len == 0)\n    if (ctx.writer.context.isTty()) .terminal else .markdown\nelse\n    std.meta.stringToEnum(OutputFormat, format_flag) orelse .markdown;\n```\n\n## Code Structure\n\n### 1. OutputFormat Enum (src/root.zig)\n```zig\npub const OutputFormat = enum {\n    markdown,\n    terminal,\n};\n```\n\n### 2. Rename Existing Function\n```zig\n// Was: lookupAndDisplay\npub fn markdownForSymbol(\n    allocator: Allocator, \n    symbol: []const u8, \n    api_json_path: ?[]const u8, \n    writer: *Writer\n) !void\n```\nKeep exact same implementation, just renamed. Generates markdown to provided writer.\n\n### 3. New Public Entry Point\n```zig\npub fn formatAndDisplay(\n    allocator: Allocator,\n    symbol: []const u8,\n    api_json_path: ?[]const u8,\n    writer: *Writer,\n    format: OutputFormat\n) !void {\n    switch (format) {\n        .markdown =\u003e try markdownForSymbol(allocator, symbol, api_json_path, writer),\n        .terminal =\u003e try renderWithZigdown(allocator, symbol, api_json_path, writer),\n    }\n}\n```\n\n### 4. Zigdown Rendering with Fallback\n```zig\nfn renderWithZigdown(\n    allocator: Allocator,\n    symbol: []const u8,\n    api_json_path: ?[]const u8,\n    writer: *Writer\n) !void {\n    // Step 1: Generate markdown to buffer (needed for zigdown)\n    var markdown_buf = std.Io.Writer.Allocating.init(allocator);\n    defer markdown_buf.deinit();\n    \n    try markdownForSymbol(allocator, symbol, api_json_path, \u0026markdown_buf.writer);\n    const markdown = try markdown_buf.toOwnedSlice();\n    defer allocator.free(markdown);\n    \n    // Step 2: Try zigdown rendering, fallback to plain markdown on error\n    renderMarkdownWithZigdown(allocator, markdown, writer) catch |err| {\n        std.debug.print(\"Warning: zigdown rendering failed ({}), falling back to markdown\\n\", .{err});\n        try writer.writeAll(markdown);\n        return;\n    };\n}\n\nfn renderMarkdownWithZigdown(allocator: Allocator, markdown: []const u8, writer: *Writer) !void {\n    var parser = zigdown.Parser.init(allocator, .{});\n    defer parser.deinit();\n    try parser.parseMarkdown(markdown);\n    \n    const term_size = zigdown.gfx.getTerminalSize() catch .{\n        .rows = 24, .cols = 80, .width = 0, .height = 0,\n    };\n    \n    var renderer = zigdown.ConsoleRenderer.init(writer, allocator, .{\n        .width = term_size.cols,\n        .indent = 0,\n        .termsize = term_size,\n        .rendering_to_buffer = false,\n        .nofetch = true,\n    });\n    defer renderer.deinit();\n    \n    try renderer.render(\u0026renderer, parser.document);\n}\n```\n\n## Error Handling\n- Markdown path: errors propagate normally (file not found, invalid JSON, symbol not found)\n- Terminal path: zigdown errors trigger fallback with stderr warning, then markdown output\n- User always gets documentation even if zigdown fails\n- Markdown already generated, so no double-rendering on fallback\n\n## Terminal Size Detection\nUses `zigdown.gfx.getTerminalSize()` which:\n- Calls `ioctl` with `TIOCGWINSZ` on Linux\n- Returns terminal dimensions (rows, cols, width, height)\n- Fallback to 80x24 if detection fails\n\n## Testing\n\n### Update Existing Tests\n- Rename all `lookupAndDisplay` calls to `markdownForSymbol`\n- No behavior changes, just function rename\n\n### New Test\n```zig\ntest \"formatAndDisplay with markdown format calls markdownForSymbol\" {\n    // Verify that .markdown format produces same output as markdownForSymbol\n}\n```\n\n### Manual Verification\n- `gdoc Node2D` - should use zigdown by default in terminal\n- `gdoc Node2D | cat` - should output markdown when piped\n- `gdoc Node2D --output-format terminal` - force zigdown\n- `gdoc Node2D --output-format markdown` - force plain markdown\n\n## Dependencies\n- Zigdown already in `build.zig.zon` ✓\n- Add import in `src/root.zig`: `const zigdown = @import(\"zigdown\");`\n- No new external dependencies required\n\n## Files to Modify\n1. `src/cli/root.zig` - Add flag, update `runLookup` to call `formatAndDisplay`\n2. `src/root.zig` - Add enum, rename function, add new functions\n3. All test files - Rename `lookupAndDisplay` to `markdownForSymbol`\n4. `README.md` - Document new flag and behavior","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-11-22T12:26:37.573657815+11:00","updated_at":"2025-11-22T15:23:37.631802869+11:00","closed_at":"2025-11-22T15:23:37.631802869+11:00","source_repo":"."}
{"id":"gdoc-ejp","content_hash":"edbece320f4e626a8a04424c565c45ee8c9ada0c3fe9f42bc1bc26de0c2b29a1","title":"Execute Godot to generate extension_api.json","description":"Run `godot --dump-extension-api-with-docs` as a subprocess, capture stdout, and save to extension_api.json cache file.","design":"## Function Signature\n```zig\npub fn generateApiJson(allocator: Allocator, godot_path: []const u8) !void\n```\n\n**Note**: Godot writes `extension_api.json` to its CWD, not stdout. We need to run godot with CWD set to the cache directory.\n\n## Implementation\n\n1. **Get cache directory and ensure it exists**:\n```zig\nconst cache_dir = try cache.getCacheDir(allocator);\ndefer allocator.free(cache_dir);\n\ntry cache.ensureCacheDir(cache_dir);\n```\n\n2. **Execute Godot subprocess with CWD set to cache directory**:\n```zig\nvar child = Child.init(\u0026[_][]const u8{ godot_path, \"--dump-extension-api-with-docs\" }, allocator);\nchild.cwd = cache_dir;\n\ntry child.spawn();\nconst term = try child.wait();\n```\n\n3. **Check exit code**:\n```zig\nswitch (term) {\n    .Exited =\u003e |code| {\n        if (code != 0) {\n            return error.GodotExecutionFailed;\n        }\n    },\n    else =\u003e return error.GodotExecutionFailed,\n}\n```\n\n## Error Handling\n\n- `error.FileNotFound` - Godot executable not found (from child.spawn())\n- `error.GodotExecutionFailed` - Godot command failed (non-zero exit)\n\n## Result\n\nAfter successful execution, `extension_api.json` will exist in the cache directory at the path returned by `cache.getJsonCachePath()`.","acceptance_criteria":"- [ ] Executes godot subprocess with --dump-extension-api-with-docs argument\n- [ ] Sets CWD to cache directory before running godot\n- [ ] extension_api.json file created in cache directory at getJsonCachePath()\n- [ ] Creates cache directory if missing via ensureCacheDir()\n- [ ] Returns error.FileNotFound if godot executable not found\n- [ ] Returns error.GodotExecutionFailed on non-zero exit code\n- [ ] Properly waits for child process to complete","status":"closed","priority":1,"issue_type":"task","created_at":"2025-11-15T23:41:25.367997709+11:00","updated_at":"2025-11-16T00:57:53.373411463+11:00","closed_at":"2025-11-16T00:57:53.373411463+11:00","source_repo":".","dependencies":[{"issue_id":"gdoc-ejp","depends_on_id":"gdoc-2id","type":"blocks","created_at":"2025-11-15T23:41:25.37072267+11:00","created_by":"daemon"}]}
{"id":"gdoc-ifo","content_hash":"797d09b94711e47fe692182a8d72b27bc9e72c61fc94b318efb3e85b7f9dc98f","title":"Add --godot flag for custom Godot executable path","description":"Allow users to specify custom path to Godot executable instead of relying on 'godot' being in $PATH.","design":"## CLI Interface\n\n```bash\ngdoc --godot /path/to/godot --clear-cache Node2D\ngdoc --godot ~/bin/godot4.5 Vector2\n```\n\n## Implementation\n\n**Add flag to zli command** (in `src/cli/root.zig` `build()` function):\n```zig\ntry root.addFlag(.{\n    .name = \"godot\",\n    .description = \"Path to Godot executable (default: 'godot' from PATH)\",\n    .type = .String,\n    .default_value = .{ .String = \"godot\" },\n});\n```\n\n**Update runLookup to pass godot path** (in `src/cli/root.zig`):\n```zig\nfn runLookup(ctx: zli.CommandContext) !void {\n    const clear_cache = ctx.flag(\"clear-cache\", bool);\n    const godot_path = ctx.flag(\"godot\", []const u8);\n    const symbol = ctx.getArg(\"symbol\");\n    \n    // Handle --clear-cache flag\n    if (clear_cache) {\n        try gdoc.clearCache();\n        try ctx.writer.print(\"Cache cleared.\\n\", .{});\n    }\n    \n    // If no symbol provided\n    if (symbol == null) {\n        if (!clear_cache) {\n            // No symbol, no clear-cache → show help\n            try ctx.command.printHelp();\n        }\n        // Symbol not provided but cache was cleared → exit cleanly\n        return;\n    }\n    \n    // Lookup symbol with error handling\n    gdoc.lookupAndDisplay(symbol.?, godot_path, ctx.writer) catch |err| switch (err) {\n        error.SymbolNotFound =\u003e {\n            try ctx.writer.print(\"Symbol '{s}' not found\\n\", .{symbol.?});\n            return;\n        },\n        error.GodotNotFound =\u003e {\n            try ctx.writer.print(\"Error: Godot executable not found at '{s}'\\n\", .{godot_path});\n            return;\n        },\n        error.GodotExecutionFailed =\u003e {\n            try ctx.writer.print(\"Error: Failed to run Godot at '{s}'\\n\", .{godot_path});\n            return;\n        },\n        // Let unexpected errors bubble up for stack trace\n        else =\u003e return err,\n    };\n}\n```\n\n**Update lookupAndDisplay signature** (in `src/root.zig`):\n```zig\npub fn lookupAndDisplay(symbol: []const u8, godot_path: []const u8, writer: anytype) !void {\n    // Load or generate cache using godot_path\n    const db = try loadOrGenerateCache(godot_path);\n    defer db.deinit();\n    \n    const entry = db.symbols.get(symbol) orelse {\n        return error.SymbolNotFound;\n    };\n    \n    try displayEntry(entry, db, writer);\n}\n```\n\n**Update cache generation to accept godot_path** (in `src/root.zig`):\n```zig\nfn loadOrGenerateCache(godot_path: []const u8) !DocDatabase {\n    // Try parsed cache first\n    // Then JSON cache\n    // Finally generate using godot_path instead of hardcoded \"godot\"\n    try generateApiJson(godot_path);\n    // ...\n}\n\nfn generateApiJson(godot_path: []const u8) !void {\n    const allocator = ...; // Get allocator\n    \n    // Check if godot_path exists\n    std.fs.accessAbsolute(godot_path, .{}) catch {\n        return error.GodotNotFound;\n    };\n    \n    // Run godot --dump-extension-api-with-docs\n    const result = try std.process.Child.run(.{\n        .allocator = allocator,\n        .argv = \u0026.{ godot_path, \"--dump-extension-api-with-docs\" },\n    });\n    defer allocator.free(result.stdout);\n    defer allocator.free(result.stderr);\n    \n    if (result.term.Exited != 0) {\n        return error.GodotExecutionFailed;\n    }\n    \n    // Write to cache\n    const cache_dir = try getCacheDir(allocator);\n    const json_path = try std.fs.path.join(allocator, \u0026.{cache_dir, \"extension_api.json\"});\n    defer allocator.free(json_path);\n    \n    try std.fs.cwd().writeFile(.{ \n        .sub_path = json_path, \n        .data = result.stdout \n    });\n}\n```\n\n## Error Handling\n\n**Expected errors** (friendly messages):\n- Custom path doesn't exist: `Error: Godot executable not found at '{s}'`\n- Execution fails: `Error: Failed to run Godot at '{s}'`\n- Symbol not found: `Symbol '{s}' not found`\n\n**Unexpected errors** (stack traces):\n- I/O failures, cache corruption, etc.\n\n## Notes\n\n- Builds on gdoc-zd9 (CLI structure with zli)\n- Uses same error handling strategy (friendly for expected, stack trace for unexpected)\n- Default value \"godot\" means it works without the flag (searches PATH)\n- Works with relative and absolute paths","acceptance_criteria":"- [ ] --godot flag accepts custom path\n- [ ] Default value is \"godot\" (from PATH)\n- [ ] Cache refresh uses custom godot path\n- [ ] Error if custom path doesn't exist\n- [ ] Error if godot execution fails\n- [ ] Works with relative and absolute paths","status":"open","priority":2,"issue_type":"feature","created_at":"2025-11-14T16:08:06.496841+11:00","updated_at":"2025-11-16T13:36:10.218370432+11:00","source_repo":".","dependencies":[{"issue_id":"gdoc-ifo","depends_on_id":"gdoc-2id","type":"blocks","created_at":"2025-11-14T16:10:47.703126+11:00","created_by":"daemon"},{"issue_id":"gdoc-ifo","depends_on_id":"gdoc-zd9","type":"blocks","created_at":"2025-11-16T13:13:30.604397583+11:00","created_by":"daemon"}]}
{"id":"gdoc-j9e","content_hash":"295308596f3bc59043c0866307818a973e2832fd7d0070c150d53f707d74113e","title":"Generate Zsh completion script","description":"Create Zsh completion function that integrates with gdoc --complete for interactive symbol completion.","design":"## Zsh Completion Script\n\n**Location**: `completions/_gdoc`\n\n**Script**:\n```zsh\n#compdef gdoc\n\n_gdoc() {\n    local -a completions\n    local cur\n\n    cur=\"${words[CURRENT]}\"\n\n    # If completing a flag\n    if [[ \"$cur\" == -* ]]; then\n        _arguments \\\n            '--clear-cache[Clear cached API data]' \\\n            '--godot[Path to Godot executable]:path:_files' \\\n            '--complete[Symbol prefix for completion]:prefix:' \\\n            '--help[Show help message]' \\\n            '--version[Show version]' \\\n            '*:symbol:_gdoc_symbols'\n    else\n        _gdoc_symbols\n    fi\n}\n\n_gdoc_symbols() {\n    local -a symbols\n    local prefix=\"${words[CURRENT]}\"\n    \n    # Call gdoc --complete\n    symbols=(${(f)\"$(gdoc --complete \"$prefix\" 2\u003e/dev/null)\"})\n    \n    _describe 'symbol' symbols\n}\n\n_gdoc \"$@\"\n```\n\n## Installation\n\nUsers add to their `~/.zshrc`:\n```zsh\nfpath=(~/.local/share/gdoc/completions $fpath)\nautoload -Uz compinit \u0026\u0026 compinit\n```\n\nOr install to system:\n```bash\nsudo cp completions/_gdoc /usr/share/zsh/site-functions/\n```\n\n## Testing\n\n```zsh\n# Reload completion\nautoload -U compinit \u0026\u0026 compinit\n\n# Test\ngdoc Node\u003cTAB\u003e\n# Should show Node, Node2D, Node3D, NodePath with descriptions\n```","acceptance_criteria":"- [ ] Zsh completion script created as _gdoc\n- [ ] Uses _gdoc and _gdoc_symbols functions\n- [ ] Calls gdoc --complete for symbol matching\n- [ ] Provides flag completion with descriptions\n- [ ] Works with partial symbols\n- [ ] Works for method completion after dot\n- [ ] Installation instructions documented","status":"open","priority":3,"issue_type":"task","created_at":"2025-11-14T16:09:40.746055+11:00","updated_at":"2025-11-14T16:09:40.746055+11:00","source_repo":".","dependencies":[{"issue_id":"gdoc-j9e","depends_on_id":"gdoc-x3v","type":"blocks","created_at":"2025-11-14T16:09:40.746622+11:00","created_by":"daemon"}]}
{"id":"gdoc-l6u","content_hash":"ba1ae5bec8c9c964300e53986b075a20f6b84a8387b395a2b6eb1c36a4473e5b","title":"Document shell completion installation","description":"Create documentation explaining how to install and use tab completion for Bash, Zsh, and Fish shells.","design":"## Documentation Location\n\nCreate `docs/COMPLETIONS.md` or add section to main README.\n\n## Content Structure\n\n### Overview\n- What tab completion provides\n- Which shells are supported\n- Prerequisites (gdoc must be installed and in PATH)\n\n### Installation by Shell\n\n**Bash**:\n```bash\n# Option 1: Source in shell config\necho 'source ~/.local/share/gdoc/completions/gdoc.bash' \u003e\u003e ~/.bashrc\nsource ~/.bashrc\n\n# Option 2: System-wide installation (requires sudo)\nsudo cp ~/.local/share/gdoc/completions/gdoc.bash /usr/share/bash-completion/completions/gdoc\n```\n\n**Zsh**:\n```zsh\n# Option 1: Add to fpath and enable compinit\nmkdir -p ~/.zsh/completions\ncp ~/.local/share/gdoc/completions/_gdoc ~/.zsh/completions/\necho 'fpath=(~/.zsh/completions $fpath)' \u003e\u003e ~/.zshrc\necho 'autoload -Uz compinit \u0026\u0026 compinit' \u003e\u003e ~/.zshrc\nsource ~/.zshrc\n\n# Option 2: System-wide installation\nsudo cp ~/.local/share/gdoc/completions/_gdoc /usr/share/zsh/site-functions/\n```\n\n**Fish**:\n```fish\n# Fish automatically loads from ~/.config/fish/completions/\nmkdir -p ~/.config/fish/completions\ncp ~/.local/share/gdoc/completions/gdoc.fish ~/.config/fish/completions/\n```\n\n### Usage Examples\n\n```bash\n# Complete class names\ngdoc Node\u003cTAB\u003e\n# Shows: Node, Node2D, Node3D, NodePath\n\n# Complete methods and properties\ngdoc Node2D.\u003cTAB\u003e\n# Shows: position, rotation, scale, global_position, ...\n\n# Complete with partial match\ngdoc Packed\u003cTAB\u003e\n# Shows: PackedByteArray, PackedColorArray, PackedFloat32Array, ...\n```\n\n### Troubleshooting\n\n- \"Completion not working\": Ensure gdoc is in PATH\n- \"Slow first completion\": First run generates cache\n- \"No suggestions\": Check cache with `gdoc --clear-cache`","acceptance_criteria":"- [ ] Documentation created in docs/COMPLETIONS.md or README\n- [ ] Installation instructions for Bash included\n- [ ] Installation instructions for Zsh included\n- [ ] Installation instructions for Fish included\n- [ ] Usage examples provided\n- [ ] Troubleshooting section included\n- [ ] Prerequisites clearly stated","status":"open","priority":3,"issue_type":"task","created_at":"2025-11-14T16:09:41.055602+11:00","updated_at":"2025-11-14T16:09:41.055602+11:00","source_repo":".","dependencies":[{"issue_id":"gdoc-l6u","depends_on_id":"gdoc-x3v","type":"blocks","created_at":"2025-11-14T16:09:41.05619+11:00","created_by":"daemon"}]}
{"id":"gdoc-m47","content_hash":"31df79cacb347063dd246c2f9f5fa093aa4e6b01ec4a9a637ec65714800119d8","title":"Generate Bash completion script","description":"Create Bash completion script that integrates with gdoc --complete for interactive symbol completion.","design":"## Bash Completion Script\n\n**Location**: `completions/gdoc.bash` (bundled with project)\n\n**Script**:\n```bash\n# Bash completion for gdoc\n_gdoc_complete() {\n    local cur prev words cword\n    _init_completion || return\n\n    # Get current word being completed\n    cur=\"${COMP_WORDS[COMP_CWORD]}\"\n    \n    # Check if we're completing a symbol (not a flag)\n    if [[ \"$cur\" != -* ]]; then\n        # Call gdoc --complete with current prefix\n        local completions=$(gdoc --complete \"$cur\" 2\u003e/dev/null)\n        COMPREPLY=($(comptime -W \"$completions\" -- \"$cur\"))\n    else\n        # Complete flags\n        local flags=\"--clear-cache --godot --help --version --complete\"\n        COMPREPLY=($(compgen -W \"$flags\" -- \"$cur\"))\n    fi\n}\n\ncomplete -F _gdoc_complete gdoc\n```\n\n## Installation Instructions\n\nUsers add to their `~/.bashrc`:\n```bash\nsource /path/to/gdoc/completions/gdoc.bash\n```\n\nOr install to system completion directory:\n```bash\nsudo cp completions/gdoc.bash /usr/share/bash-completion/completions/gdoc\n```\n\n## Testing\n\n```bash\n# Source the script\nsource completions/gdoc.bash\n\n# Test completion\ngdoc Node\u003cTAB\u003e\n# Should suggest: Node Node2D Node3D NodePath\n\ngdoc Node2D.\u003cTAB\u003e\n# Should suggest: Node2D.position Node2D.rotation etc.\n```","acceptance_criteria":"- [ ] Bash completion script created in completions/\n- [ ] Script uses _gdoc_complete function\n- [ ] Calls gdoc --complete for symbol completion\n- [ ] Completes flags when typing --\n- [ ] Works with partial symbol names\n- [ ] Works after dot for method completion\n- [ ] Installation instructions documented","status":"open","priority":3,"issue_type":"task","created_at":"2025-11-14T16:09:40.595571+11:00","updated_at":"2025-11-14T16:09:40.595571+11:00","source_repo":".","dependencies":[{"issue_id":"gdoc-m47","depends_on_id":"gdoc-x3v","type":"blocks","created_at":"2025-11-14T16:09:40.59689+11:00","created_by":"daemon"}]}
{"id":"gdoc-mqq","content_hash":"fee143e601c4f9378d9595e843b24e36fdfbfdcd05851c276e17a2f26a6fa9ba","title":"Parse extension_api.json into flat StringArrayHashMap","description":"Parse Godot extension API JSON into optimized lookup structure with all symbols in a flat StringArrayHashMap. Convert BBCode docs to Markdown using bbcodez.","design":"## Data Structures\n\n```zig\npub const DocDatabase = struct {\n    // ArrayHashMap: get by key OR by index\n    symbols: std.StringArrayHashMap(DocEntry),\n    allocator: Allocator,\n};\n\npub const DocEntry = struct {\n    name: []const u8,           // \"append\", \"sin\", \"Node2D\"\n    full_path: []const u8,      // \"PackedVectorArray.append\", \"Node2D\"\n    parent_index: ?usize,       // Index into symbols array, null for top-level\n    kind: EntryKind,\n    description: []const u8,    // Markdown (converted from BBCode)\n    signature: ?[]const u8,     // \"fn append(value: Variant)\"\n    members: ?[]usize,          // Indices of members (not strings)\n};\n\npub const EntryKind = enum {\n    builtin_class,\n    class,\n    method,\n    property,\n    constant,\n    enum_value,\n    global_function,\n    operator,\n};\n```\n\n## Flat Namespace Strategy\n\nAll symbols stored in single HashMap:\n- Classes: `\"PackedVectorArray\"` → class entry with `.members` list\n- Methods: `\"PackedVectorArray.append\"` → method entry with signature\n- Properties: `\"Node2D.position\"` → property entry\n- Globals: `\"sin\"` → global function (strip `@GlobalScope.` prefix)\n- Enums: `\"AESContext.Mode\"` → enum entry\n- Enum values: `\"AESContext.Mode.MODE_ECB_ENCRYPT\"` → enum value entry\n\n## @GlobalScope Handling\n\nWhen parsing JSON:\n```zig\nif (std.mem.startsWith(u8, full_name, \"@GlobalScope.\")) {\n    const key = full_name[\"@GlobalScope.\".len..];  // \"sin\"\n    // Store under \"sin\", not \"@GlobalScope.sin\"\n}\n```\n\n## BBCode to Markdown Conversion\n\n- Parse JSON\n- For each description field (BBCode)\n- Use `bbcodez` to convert to Markdown\n- Store Markdown in DocEntry\n- Godot BBCode tags: `[b]`, `[i]`, `[code]`, `[codeblock]`, `[url]`, `[param]`, etc.\n\n## Implementation Tasks\n\n- Define DocDatabase and DocEntry structs\n- Implement JSON parsing for `builtin_classes` array\n- Implement JSON parsing for `classes` array\n- Implement JSON parsing for global scope functions\n- Merge all into single StringArrayHashMap\n- Build parent_index and members relationships\n- Integrate bbcodez for BBCode → Markdown conversion\n- Write unit tests for parsing sample JSON","acceptance_criteria":"- [ ] DocDatabase struct with StringArrayHashMap implemented\n- [ ] Parses builtin_classes from JSON into HashMap\n- [ ] Parses classes from JSON into HashMap\n- [ ] Parses global functions (strips @GlobalScope prefix)\n- [ ] Parent/child relationships stored as indices\n- [ ] Members lists stored as indices (not strings)\n- [ ] All BBCode descriptions converted to Markdown using bbcodez\n- [ ] Unit tests verify parsing of sample classes/methods/properties","status":"closed","priority":1,"issue_type":"feature","assignee":"Simon Hartcher","created_at":"2025-11-14T16:06:55.715924+11:00","updated_at":"2025-11-15T13:49:00.179665678+11:00","closed_at":"2025-11-15T13:49:00.179665678+11:00","source_repo":"."}
{"id":"gdoc-p9g","content_hash":"587f4de7d453439ea5bf0520dda9eadea0d73c34ca12546bd5e4605d3cf03b65","title":"Add GitHub API download fallback for extension_api.json","description":"Download extension_api.json from Godot's GitHub releases when Godot executable is not available. Low priority enhancement for users without Godot installed.","design":"## Use Case\n\nWhen cache doesn't exist and Godot is not installed:\n```bash\n$ gdoc Node2D\nCache not found. Godot executable not available.\nDownloading extension_api.json from GitHub (latest stable)...\n[progress indicator]\nDownloaded Godot 4.5.1 API documentation.\nParsing and caching...\nDone.\n\n\u003cshows Node2D documentation\u003e\n```\n\n## Implementation Strategy\n\n**GitHub API Endpoint**:\n```\nGET https://api.github.com/repos/godotengine/godot/releases/latest\n```\n\nResponse includes release info and assets. Need to find the correct asset URL for extension API JSON.\n\n**HTTP Client in Zig**:\n```zig\nconst std = @import(\"std\");\n\nfn downloadApiFromGitHub(allocator: Allocator) ![]u8 {\n    var client = std.http.Client{ .allocator = allocator };\n    defer client.deinit();\n    \n    // 1. Get latest release info\n    const release_url = \"https://api.github.com/repos/godotengine/godot/releases/latest\";\n    \n    var headers = std.http.Headers{ .allocator = allocator };\n    defer headers.deinit();\n    try headers.append(\"User-Agent\", \"gdoc/0.1.0\");\n    \n    var req = try client.fetch(.{\n        .location = .{ .url = release_url },\n        .headers = headers,\n    });\n    defer req.deinit();\n    \n    // 2. Parse JSON response to find extension_api.json asset\n    // Note: May not be in releases - might need to fetch from repo directly\n    \n    // 3. Download the asset\n    // 4. Return JSON content\n}\n```\n\n## Challenges\n\n- **Finding the API JSON**: It may not be in releases; might be in `doc/classes` or generated\n- **Rate limiting**: GitHub API has rate limits (60/hour unauthenticated)\n- **Version matching**: Ensure we get stable release, not pre-release\n- **Alternative locations**: May need to fetch from repo tree instead of releases\n\n## Alternative Approach\n\nIf extension_api.json is not in releases, fetch from a known stable branch:\n```\nhttps://raw.githubusercontent.com/godotengine/godot/master/doc/extension_api.json\n```\n\nOr generate URL pattern based on latest tag.\n\n## Error Handling\n\n- Network errors: \"Failed to download from GitHub: {error}\"\n- Rate limiting: \"GitHub API rate limit exceeded. Please install Godot or try again later.\"\n- Not found: \"Could not find extension_api.json in latest release\"\n\n## Future Enhancement\n\n- Add `--api-url` flag to specify custom API JSON URL\n- Cache multiple versions (Godot 4.3, 4.4, 4.5, etc.)","acceptance_criteria":"- [ ] Downloads extension_api.json from GitHub when Godot not found\n- [ ] Uses std.http.Client for HTTP requests\n- [ ] Finds correct API JSON from releases or repository\n- [ ] Shows progress/status message during download\n- [ ] Handles rate limiting gracefully\n- [ ] Handles network errors with clear messages\n- [ ] Only stable releases (not pre-releases)\n- [ ] Works without requiring Godot installation","status":"closed","priority":3,"issue_type":"feature","created_at":"2025-11-14T16:10:04.447527+11:00","updated_at":"2025-11-23T00:13:35.604526943+11:00","closed_at":"2025-11-23T00:13:35.604526943+11:00","source_repo":".","dependencies":[{"issue_id":"gdoc-p9g","depends_on_id":"gdoc-2id","type":"blocks","created_at":"2025-11-14T16:10:47.847414+11:00","created_by":"daemon"}]}
{"id":"gdoc-pvx","content_hash":"939215ae92fafc4aa99608e8c475bb85a2519eb09099f17b97da92bef8615cee","title":"Replace binary cache with markdown-based file-per-symbol cache","description":"Replace the current binary cache system (extension_api.parsed with custom format) with a file-per-symbol markdown cache. Each symbol gets its own markdown file, making lookups a simple file read operation.","design":"## Overview\n\nReplace the current binary cache system (`extension_api.parsed` with custom format) with a **file-per-symbol markdown cache**. Each symbol gets its own markdown file, making lookups a simple file read operation.\n\n## Cache Directory Structure\n\n```\n~/.cache/gdoc/\n  sin.md                    # Global utility function\n  cos.md                    # Global utility function\n  abs.md\n  Node2D/\n    index.md                # Class documentation\n    position.md             # Property documentation\n    rotation.md\n    get_child.md            # Method documentation\n    set_position.md\n  PackedByteArray/\n    index.md\n    append.md\n    resize.md\n```\n\n**Organization rules:**\n- **Classes** → directories with `index.md` for class-level docs\n- **Class members** → individual `.md` files in parent class directory\n- **Global functions** → top-level `.md` files\n\n## Cache Population Strategy\n\n**Two modes based on CLI usage:**\n\n1. **Normal cache flow** (`gdoc Node2D`):\n   - Check if cache directory exists and is populated\n   - If empty: Parse entire `extension_api.json` once, generate ALL markdown files\n   - Lookup: Read `Node2D/index.md` directly\n\n2. **Bypass cache** (`gdoc --godot-extension-api api.json Node2D`):\n   - Parse JSON to find only the requested symbol\n   - Generate markdown in-memory (ephemeral, don't write to disk)\n   - Return directly to user\n\n## Symbol Lookup Algorithm\n\n**File path resolution for `gdoc \u003csymbol\u003e`:**\n\n```zig\nfn resolveSymbolPath(allocator: Allocator, cache_dir: []const u8, symbol: []const u8) ![]const u8 {\n    // Case 1: Member lookup (contains dot)\n    if (std.mem.indexOf(u8, symbol, \".\")) |dot_pos| {\n        const class_name = symbol[0..dot_pos];\n        const member_name = symbol[dot_pos+1..];\n        return std.fmt.allocPrint(\n            allocator,\n            \"{s}/{s}/{s}.md\",\n            .{cache_dir, class_name, member_name}\n        );\n    }\n    \n    // Case 2: Try global function first (simple file)\n    const global_path = try std.fmt.allocPrint(\n        allocator,\n        \"{s}/{s}.md\",\n        .{cache_dir, symbol}\n    );\n    \n    // Check if file exists\n    std.fs.accessAbsolute(global_path, .{}) catch |err| {\n        allocator.free(global_path);\n        if (err == error.FileNotFound) {\n            // Case 3: Try as class (directory/index.md)\n            return std.fmt.allocPrint(\n                allocator,\n                \"{s}/{s}/index.md\",\n                .{cache_dir, symbol}\n            );\n        }\n        return err;\n    };\n    \n    return global_path;\n}\n```\n\n**Error handling:**\n- File doesn't exist → `error.SymbolNotFound`\n- File exists but unreadable → propagate I/O error\n\n## Cache Invalidation\n\n**Manual only** - no automatic invalidation:\n- Users explicitly run `gdoc --clear-cache` when upgrading Godot\n- Cache persists across sessions until cleared\n- Simple, predictable behavior\n\n## Markdown File Formats\n\n**Class index file** (`Node2D/index.md`):\n```markdown\n# Node2D\n\nA 2D game object with **position** and **rotation**.\n\n## Description\n\n(Full converted markdown description from BBCode)\n\n## Properties\n- position\n- rotation\n- scale\n- global_position\n\n## Methods\n- get_child\n- set_position\n- move_local_x\n- rotate\n\n## Constants\n- (if any exist)\n```\n\n**Member file** (`Node2D/position.md`):\n```markdown\n# Node2D.position\n\n**Type:** Vector2  \n**Parent:** Node2D\n\n## Description\n\nPosition, relative to the node's parent.\n\n(Full converted markdown description)\n```\n\n**Global function file** (`sin.md`):\n```markdown\n# sin\n\n**Type:** global_function\n\n## Description\n\nReturns the sine of angle in radians.\n\n(Full converted markdown description)\n```\n\n## BBCode Conversion\n\n**When:** During cache generation (convert once, read many times)\n\n**How:** Use existing `bbcodez` integration in `DocDatabase.zig`:\n- BBCode → Markdown conversion already implemented (line 130-139)\n- `[b]text[/b]` → `**text**`\n- `[i]text[/i]` → `*text*`\n- `[code]text[/code]` → `` `text` ``\n\n## Code Structure Changes\n\n**Modify `src/cache.zig`:**\n\nRemove binary cache logic (`CacheFile`, `CacheHeader`, `writeCacheFile`, `readCacheFile`) and replace with:\n\n```zig\n// Keep existing helper functions:\n// - getCacheDir()\n// - ensureDirectoryExists()\n// - clearCache() - now deletes markdown files instead\n\n// Add new functions:\n\n/// Generate all markdown files from parsed DocDatabase\npub fn generateMarkdownCache(\n    allocator: Allocator, \n    db: DocDatabase, \n    cache_dir: []const u8\n) !void {\n    try ensureDirectoryExists(cache_dir);\n    \n    // Iterate through all symbols\n    for (db.symbols.keys(), db.symbols.values()) |key, entry| {\n        try writeSymbolMarkdown(allocator, entry, db, cache_dir);\n    }\n}\n\n/// Write markdown file for a single symbol\nfn writeSymbolMarkdown(\n    allocator: Allocator,\n    entry: DocDatabase.Entry,\n    db: DocDatabase,\n    cache_dir: []const u8\n) !void {\n    const markdown = try generateMarkdownForEntry(allocator, entry, db);\n    defer allocator.free(markdown);\n    \n    const file_path = try getMarkdownPath(allocator, cache_dir, entry);\n    defer allocator.free(file_path);\n    \n    // Ensure parent directory exists\n    if (std.fs.path.dirname(file_path)) |dir| {\n        try ensureDirectoryExists(dir);\n    }\n    \n    try std.fs.cwd().writeFile(.{\n        .sub_path = file_path,\n        .data = markdown,\n    });\n}\n\n/// Lookup symbol and return markdown content\npub fn readSymbolMarkdown(\n    allocator: Allocator,\n    symbol: []const u8,\n    cache_dir: []const u8\n) ![]const u8 {\n    const file_path = try resolveSymbolPath(allocator, cache_dir, symbol);\n    defer allocator.free(file_path);\n    \n    return std.fs.cwd().readFileAlloc(\n        allocator,\n        file_path,\n        10 * 1024 * 1024  // 10MB max\n    ) catch |err| switch (err) {\n        error.FileNotFound =\u003e error.SymbolNotFound,\n        else =\u003e err,\n    };\n}\n```\n\n## Markdown Generation Logic\n\n**Add to `src/cache.zig`:**\n\n```zig\n/// Generate markdown content for an entry\nfn generateMarkdownForEntry(\n    allocator: Allocator,\n    entry: DocDatabase.Entry,\n    db: DocDatabase\n) ![]const u8 {\n    var buf = std.ArrayList(u8).init(allocator);\n    errdefer buf.deinit();\n    const writer = buf.writer();\n    \n    switch (entry.kind) {\n        .class, .builtin_class =\u003e {\n            try writeClassMarkdown(writer, entry, db);\n        },\n        .method, .property, .constant, .enum_value =\u003e {\n            try writeMemberMarkdown(writer, entry, db);\n        },\n        .global_function =\u003e {\n            try writeGlobalFunctionMarkdown(writer, entry);\n        },\n        .operator =\u003e {\n            try writeOperatorMarkdown(writer, entry, db);\n        },\n    }\n    \n    return buf.toOwnedSlice();\n}\n\nfn writeClassMarkdown(\n    writer: anytype,\n    entry: DocDatabase.Entry,\n    db: DocDatabase\n) !void {\n    // Header\n    try writer.print(\"# {s}\\n\\n\", .{entry.name});\n    \n    // Brief description\n    if (entry.brief_description) |brief| {\n        try writer.print(\"{s}\\n\\n\", .{brief});\n    }\n    \n    // Full description\n    if (entry.description) |desc| {\n        try writer.print(\"## Description\\n\\n{s}\\n\\n\", .{desc});\n    }\n    \n    // Members grouped by kind\n    if (entry.members) |member_indices| {\n        try writeGroupedMembers(writer, member_indices, db);\n    }\n}\n\nfn writeGroupedMembers(\n    writer: anytype,\n    member_indices: []const usize,\n    db: DocDatabase\n) !void {\n    // Group members by kind\n    var properties = std.ArrayList(usize).init(db.allocator);\n    var methods = std.ArrayList(usize).init(db.allocator);\n    var constants = std.ArrayList(usize).init(db.allocator);\n    var operators = std.ArrayList(usize).init(db.allocator);\n    defer properties.deinit();\n    defer methods.deinit();\n    defer constants.deinit();\n    defer operators.deinit();\n    \n    for (member_indices) |idx| {\n        const member = db.symbols.values()[idx];\n        switch (member.kind) {\n            .property =\u003e try properties.append(idx),\n            .method =\u003e try methods.append(idx),\n            .constant, .enum_value =\u003e try constants.append(idx),\n            .operator =\u003e try operators.append(idx),\n            else =\u003e {},\n        }\n    }\n    \n    // Write each group\n    if (properties.items.len \u003e 0) {\n        try writer.writeAll(\"## Properties\\n\");\n        for (properties.items) |idx| {\n            const prop = db.symbols.values()[idx];\n            try writer.print(\"- {s}\\n\", .{prop.name});\n        }\n        try writer.writeAll(\"\\n\");\n    }\n    \n    if (methods.items.len \u003e 0) {\n        try writer.writeAll(\"## Methods\\n\");\n        for (methods.items) |idx| {\n            const method = db.symbols.values()[idx];\n            try writer.print(\"- {s}\\n\", .{method.name});\n        }\n        try writer.writeAll(\"\\n\");\n    }\n    \n    if (constants.items.len \u003e 0) {\n        try writer.writeAll(\"## Constants\\n\");\n        for (constants.items) |idx| {\n            const constant = db.symbols.values()[idx];\n            try writer.print(\"- {s}\\n\", .{constant.name});\n        }\n        try writer.writeAll(\"\\n\");\n    }\n    \n    if (operators.items.len \u003e 0) {\n        try writer.writeAll(\"## Operators\\n\");\n        for (operators.items) |idx| {\n            const op = db.symbols.values()[idx];\n            try writer.print(\"- {s}\\n\", .{op.name});\n        }\n        try writer.writeAll(\"\\n\");\n    }\n}\n\nfn writeMemberMarkdown(\n    writer: anytype,\n    entry: DocDatabase.Entry,\n    db: DocDatabase\n) !void {\n    // Header with full path\n    try writer.print(\"# {s}\\n\\n\", .{entry.key});\n    \n    // Metadata\n    if (entry.parent_index) |idx| {\n        const parent = db.symbols.values()[idx];\n        try writer.print(\"**Parent:** {s}  \\n\", .{parent.name});\n    }\n    \n    try writer.print(\"**Type:** {s}  \\n\\n\", .{@tagName(entry.kind)});\n    \n    if (entry.signature) |sig| {\n        try writer.print(\"**Signature:** {s}  \\n\\n\", .{sig});\n    }\n    \n    // Description\n    if (entry.description) |desc| {\n        try writer.print(\"## Description\\n\\n{s}\\n\", .{desc});\n    } else if (entry.brief_description) |brief| {\n        try writer.print(\"## Description\\n\\n{s}\\n\", .{brief});\n    }\n}\n\nfn writeGlobalFunctionMarkdown(\n    writer: anytype,\n    entry: DocDatabase.Entry\n) !void {\n    try writer.print(\"# {s}\\n\\n\", .{entry.name});\n    try writer.writeAll(\"**Type:** global_function  \\n\\n\");\n    \n    if (entry.signature) |sig| {\n        try writer.print(\"**Signature:** {s}  \\n\\n\", .{sig});\n    }\n    \n    if (entry.description) |desc| {\n        try writer.print(\"## Description\\n\\n{s}\\n\", .{desc});\n    } else if (entry.brief_description) |brief| {\n        try writer.print(\"## Description\\n\\n{s}\\n\", .{brief});\n    }\n}\n\nfn writeOperatorMarkdown(\n    writer: anytype,\n    entry: DocDatabase.Entry,\n    db: DocDatabase\n) !void {\n    // Similar to writeMemberMarkdown\n    try writeMemberMarkdown(writer, entry, db);\n}\n```\n\n## Integration with Existing Code\n\n**Modify `src/root.zig` - Update `lookupAndDisplay`:**\n\n```zig\npub fn lookupAndDisplay(\n    allocator: Allocator, \n    symbol: []const u8, \n    api_json_path: ?[]const u8, \n    writer: *Writer\n) !void {\n    if (api_json_path) |path| {\n        // Bypass cache - load JSON and generate markdown in-memory\n        const api_json_file = std.fs.cwd().openFile(path, .{}) catch |err| switch (err) {\n            error.FileNotFound =\u003e return LookupError.ApiFileNotFound,\n            else =\u003e return err,\n        };\n        defer api_json_file.close();\n        \n        var arena = ArenaAllocator.init(allocator);\n        defer arena.deinit();\n        \n        const db = try DocDatabase.loadFromJsonFileLeaky(arena.allocator(), api_json_file);\n        const entry = try db.lookupSymbolExact(symbol);\n        \n        // Generate markdown in-memory (don't cache)\n        const markdown = try cache.generateMarkdownForEntry(allocator, entry, db);\n        defer allocator.free(markdown);\n        \n        try writer.writeAll(markdown);\n    } else {\n        // Normal cache flow\n        const cache_dir = try cache.getCacheDir(allocator);\n        defer allocator.free(cache_dir);\n        \n        // Check if cache exists and is populated\n        const cache_exists = cacheIsPopulated(cache_dir) catch false;\n        \n        if (!cache_exists) {\n            // Generate cache from Godot or downloaded JSON\n            try populateCache(allocator, cache_dir);\n        }\n        \n        // Read symbol markdown from cache\n        const markdown = try cache.readSymbolMarkdown(allocator, symbol, cache_dir);\n        defer allocator.free(markdown);\n        \n        try writer.writeAll(markdown);\n    }\n}\n\nfn cacheIsPopulated(cache_dir: []const u8) !bool {\n    // Check if cache directory exists and has content\n    var dir = try std.fs.openDirAbsolute(cache_dir, .{ .iterate = true });\n    defer dir.close();\n    \n    var iter = dir.iterate();\n    // If we can get at least one entry, cache is populated\n    return (try iter.next()) != null;\n}\n\nfn populateCache(allocator: Allocator, cache_dir: []const u8) !void {\n    // Get JSON (from Godot or download)\n    const json_path = try cache.getJsonCachePath(allocator);\n    defer allocator.free(json_path);\n    \n    // Ensure JSON exists (generate from Godot if needed)\n    try api.ensureApiJsonExists(allocator, json_path);\n    \n    // Parse JSON\n    const json_file = try std.fs.openFileAbsolute(json_path, .{});\n    defer json_file.close();\n    \n    var arena = ArenaAllocator.init(allocator);\n    defer arena.deinit();\n    \n    const db = try DocDatabase.loadFromJsonFileLeaky(arena.allocator(), json_file);\n    \n    // Generate all markdown files\n    try cache.generateMarkdownCache(allocator, db, cache_dir);\n}\n```\n\n**Modify `src/api.zig` - Add helper:**\n\n```zig\n/// Ensure extension_api.json exists, generate if needed\npub fn ensureApiJsonExists(allocator: Allocator, json_path: []const u8) !void {\n    // Check if file exists\n    std.fs.accessAbsolute(json_path, .{}) catch {\n        // File doesn't exist - generate it\n        const cache_dir = std.fs.path.dirname(json_path) orelse return error.InvalidPath;\n        \n        // Try to find godot executable\n        const godot_path = \"godot\"; // Could be made configurable\n        try generateApiJson(allocator, godot_path, cache_dir);\n    };\n}\n```\n\n## Testing Strategy\n\n**Update existing tests:**\n\n1. **`src/root.zig` tests** - Update to work with markdown cache:\n   - Tests that currently use `lookupAndDisplay` should still work\n   - They'll generate markdown cache in temp directories\n   - Verify markdown output contains expected content\n\n2. **New `src/cache.zig` tests**:\n\n```zig\ntest \"generateMarkdownCache creates directory structure\" {\n    const allocator = std.testing.allocator;\n    \n    var tmp_dir = std.testing.tmpDir(.{});\n    defer tmp_dir.cleanup();\n    \n    const cache_path = try tmp_dir.dir.realpathAlloc(allocator, \".\");\n    defer allocator.free(cache_path);\n    \n    // Create minimal DocDatabase\n    var db = DocDatabase.empty;\n    // ... populate with test data ...\n    \n    try generateMarkdownCache(allocator, db, cache_path);\n    \n    // Verify files exist\n    var dir = try std.fs.openDirAbsolute(cache_path, .{});\n    defer dir.close();\n    \n    _ = try dir.openFile(\"Node2D/index.md\", .{});\n    _ = try dir.openFile(\"Node2D/position.md\", .{});\n}\n\ntest \"readSymbolMarkdown returns file content\" {\n    // Create cache directory with test markdown\n    // Call readSymbolMarkdown\n    // Verify content matches\n}\n\ntest \"readSymbolMarkdown returns SymbolNotFound for missing file\" {\n    // Verify error.SymbolNotFound for nonexistent symbol\n}\n\ntest \"resolveSymbolPath handles dot notation\" {\n    // Verify \"Node2D.position\" -\u003e \"cache/Node2D/position.md\"\n}\n\ntest \"resolveSymbolPath tries global then class\" {\n    // Verify \"sin\" -\u003e \"cache/sin.md\" if exists\n    // Otherwise -\u003e \"cache/sin/index.md\"\n}\n```\n\n## Migration Path\n\n**Phase 1: Remove old binary cache code**\n- Delete: `CacheFile`, `CacheHeader`, `writeCacheFile`, `readCacheFile`\n- Keep: `getCacheDir`, `getJsonCachePath`, `ensureDirectoryExists`, `clearCache`\n\n**Phase 2: Add markdown generation**\n- Implement `generateMarkdownCache`, `writeSymbolMarkdown`, etc.\n- Add markdown generation functions\n\n**Phase 3: Update integration points**\n- Modify `lookupAndDisplay` in `src/root.zig`\n- Update `src/api.zig` with `ensureApiJsonExists`\n\n**Phase 4: Test and validate**\n- Run existing tests\n- Manual testing with real Godot API\n- Verify `--clear-cache` still works","notes":"## Progress Update\n\n### ✅ Completed Components (via TDPP)\n\n1. **`resolveSymbolPath`** - Maps symbol names to file paths\n   - Simplified design: All symbols go to subdirectories (`symbol/index.md`)\n   - Members use dot notation: `Class.member` → `Class/member.md`\n   - Tests passing ✓\n\n2. **`DocDatabase.generateMarkdownForSymbol` / `generateMarkdownForEntry`** - Converts entries to markdown\n   - Writer-based API for streaming output\n   - Snapshot testing setup with jujutsu compatibility\n   - Tests passing ✓\n   - Snapshots committed ✓\n\n3. **`writeSymbolMarkdown`** - Write single symbol's markdown to cache\n   - Uses `resolveSymbolPath` for consistent paths\n   - Automatic parent directory creation\n   - Integrates with `generateMarkdownForSymbol`\n   - Tests passing ✓\n\n### 🔄 Design Changes\n\n**Simplified symbol resolution:**\n- Original: Global functions at top-level (`sin.md`), classes in subdirs\n- New: Everything in subdirs for consistency (`sin/index.md`, `Node2D/index.md`)\n- Benefits: Simpler code, no file existence checks, more maintainable\n\n### 📋 Next Steps\n\nPhase 2 remaining tasks:\n- [ ] `generateMarkdownCache` - Generate ALL markdown files from DocDatabase\n- [ ] `readSymbolMarkdown` - Read markdown from cache files\n\nPhase 3: Integration\n- [ ] Update `lookupAndDisplay` in `src/root.zig`\n- [ ] Add `ensureApiJsonExists` helper\n\nPhase 4: Testing \u0026 Cleanup\n- [ ] Remove old binary cache code (`CacheFile`, `CacheHeader`, etc.)\n- [ ] Manual testing with real Godot API\n- [ ] Verify `--clear-cache` still works","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-11-22T13:01:44.863882735+11:00","updated_at":"2025-11-23T00:06:54.905648185+11:00","closed_at":"2025-11-23T00:06:54.905648185+11:00","source_repo":"."}
{"id":"gdoc-pwp","content_hash":"39298a142e093b7ae40dc2cd4c78489fc2055f2b1ddcfec0ee2443c20e510490","title":"Generate Fish completion script","description":"Create Fish shell completion configuration that integrates with gdoc --complete for interactive symbol completion.","design":"## Fish Completion Script\n\n**Location**: `completions/gdoc.fish`\n\n**Script**:\n```fish\n# Fish completion for gdoc\n\n# Flag completions\ncomplete -c gdoc -l clear-cache -d 'Clear cached API data'\ncomplete -c gdoc -l godot -d 'Path to Godot executable' -r -F\ncomplete -c gdoc -l complete -d 'Symbol prefix for completion' -x\ncomplete -c gdoc -l help -d 'Show help message'\ncomplete -c gdoc -l version -d 'Show version'\n\n# Symbol completion function\nfunction __fish_gdoc_complete_symbols\n    set -l cmd (commandline -opc)\n    set -l current (commandline -ct)\n    \n    # Don't complete if we're typing a flag\n    if string match -q -- '-*' $current\n        return\n    end\n    \n    # Call gdoc --complete with current token\n    gdoc --complete \"$current\" 2\u003e/dev/null\nend\n\n# Register symbol completion\ncomplete -c gdoc -f -a '(__fish_gdoc_complete_symbols)'\n```\n\n## Installation\n\nUsers add to their Fish config:\n```fish\n# In ~/.config/fish/config.fish\nsource ~/.local/share/gdoc/completions/gdoc.fish\n```\n\nOr install to Fish completions directory:\n```bash\ncp completions/gdoc.fish ~/.config/fish/completions/\n```\n\n## Testing\n\n```fish\n# Reload completions\nsource ~/.config/fish/completions/gdoc.fish\n\n# Test\ngdoc Node\u003cTAB\u003e\n# Should show Node, Node2D, Node3D, NodePath\n\ngdoc Node2D.\u003cTAB\u003e\n# Should show Node2D.position, etc.\n```","acceptance_criteria":"- [ ] Fish completion script created as gdoc.fish\n- [ ] Declares flag completions with descriptions\n- [ ] Uses __fish_gdoc_complete_symbols function\n- [ ] Calls gdoc --complete for symbol matching\n- [ ] Works with partial symbols\n- [ ] Works for method completion after dot\n- [ ] Installation instructions documented","status":"open","priority":3,"issue_type":"task","created_at":"2025-11-14T16:09:40.902136+11:00","updated_at":"2025-11-14T16:09:40.902136+11:00","source_repo":".","dependencies":[{"issue_id":"gdoc-pwp","depends_on_id":"gdoc-x3v","type":"blocks","created_at":"2025-11-14T16:09:40.902764+11:00","created_by":"daemon"}]}
{"id":"gdoc-r48","content_hash":"c8457c98e75cd2215df8a6716840cbfb4a3b5a48b95bd6647a505271468a8642","title":"Phase 2: Build signatures for methods, properties, constants, signals","description":"Parse return types, arguments, and types to build proper signatures for all member types. Format signatures appropriately for each kind (methods with params/return, properties with types, etc).","design":"## Goal\n\nBuild Entry.signature field for all member types by parsing additional JSON fields.\n\n## Signature Formats\n\n**Methods:**\n```\n(node: Node, force_readable_name: bool = false) -\u003e void\n```\n\n**Properties:**\n```\n: Vector2\n```\n\n**Constants:**\n```\n: int = 30\n```\n\n**Signals:**\n```\n(body: Node3D)\n```\n\n**Global Functions:**\n```\n(angle_rad: float) -\u003e float\n```\n\n## JSON Fields to Parse\n\n### For Methods\n```json\n{\n  \"name\": \"add_child\",\n  \"return_value\": {          // Parse this\n    \"type\": \"void\"\n  },\n  \"arguments\": [             // Parse this\n    {\n      \"name\": \"node\",\n      \"type\": \"Node\",\n      \"default_value\": \"null\"\n    }\n  ]\n}\n```\n\n### For Utility Functions (global functions)\n```json\n{\n  \"name\": \"sin\",\n  \"return_type\": \"float\",    // Parse this (simpler than return_value)\n  \"arguments\": [...]\n}\n```\n\n### For Properties\n```json\n{\n  \"name\": \"position\",\n  \"type\": \"Vector2\"          // Parse this\n}\n```\n\n### For Constants\n```json\n{\n  \"name\": \"NOTIFICATION_READY\",\n  \"value\": 30                // Parse this\n}\n```\n\n### For Signals\n```json\n{\n  \"name\": \"body_entered\",\n  \"arguments\": [             // Parse this\n    {\"name\": \"body\", \"type\": \"Node3D\"}\n  ]\n}\n```\n\n## Implementation Steps\n\n1. **Extend MethodKey enum:**\n```zig\nconst MethodKey = enum {\n    name,\n    return_value,    // NEW - for class methods\n    return_type,     // NEW - for utility_functions\n    arguments,       // NEW\n    description,     // NEW\n};\n```\n\n2. **Create signature builder functions:**\n```zig\nfn buildMethodSignature(\n    allocator: Allocator, \n    args: []Argument, \n    return_type: []const u8\n) ![]const u8 {\n    // Build: \"(arg1: Type = default, arg2: Type) -\u003e ReturnType\"\n    var buf = ArrayList(u8).init(allocator);\n    try buf.append('(');\n    \n    for (args, 0..) |arg, i| {\n        if (i \u003e 0) try buf.appendSlice(\", \");\n        try buf.appendSlice(arg.name);\n        try buf.appendSlice(\": \");\n        try buf.appendSlice(arg.type);\n        if (arg.default_value) |default| {\n            try buf.appendSlice(\" = \");\n            try buf.appendSlice(default);\n        }\n    }\n    \n    try buf.appendSlice(\") -\u003e \");\n    try buf.appendSlice(return_type);\n    \n    return buf.toOwnedSlice();\n}\n\nfn buildPropertySignature(allocator: Allocator, type_name: []const u8) ![]const u8 {\n    return std.fmt.allocPrint(allocator, \": {s}\", .{type_name});\n}\n\nfn buildConstantSignature(allocator: Allocator, value: i64) ![]const u8 {\n    return std.fmt.allocPrint(allocator, \" = {d}\", .{value});\n}\n```\n\n3. **Define Argument struct:**\n```zig\nconst Argument = struct {\n    name: []const u8,\n    type: []const u8,\n    default_value: ?[]const u8 = null,\n};\n```\n\n4. **Parse arguments array:**\n```zig\nfn parseArguments(allocator: Allocator, scanner: *Scanner) ![]Argument {\n    var args = ArrayList(Argument).init(allocator);\n    \n    while (try scanner.next()) {\n        switch (token) {\n            .object_begin =\u003e {\n                var arg: Argument = undefined;\n                while (...) {\n                    // Parse name, type, default_value\n                }\n                try args.append(arg);\n            }\n            .array_end =\u003e break,\n        }\n    }\n    \n    return args.toOwnedSlice();\n}\n```\n\n5. **Update parseMethod to build signature:**\n```zig\nfn parseMethod(...) {\n    var method: Entry = ...;\n    var args: []Argument = \u0026.{};\n    var return_type: ?[]const u8 = null;\n    \n    while (...) {\n        switch (method_key) {\n            .arguments =\u003e args = try parseArguments(allocator, scanner),\n            .return_value =\u003e return_type = try parseReturnValue(...),\n            .return_type =\u003e return_type = try scanner.next().string,\n        }\n    }\n    \n    if (return_type) |rt| {\n        method.signature = try buildMethodSignature(allocator, args, rt);\n    }\n}\n```\n\n## Testing\n\n```zig\ntest \"method signature with arguments and return\" {\n    const json = \\\\{\n      \"name\": \"add_child\",\n      \"return_value\": {\"type\": \"void\"},\n      \"arguments\": [\n        {\"name\": \"node\", \"type\": \"Node\", \"default_value\": \"null\"}\n      ]\n    }\n    \n    const method = try parseMethod(...);\n    try testing.expectEqualStrings(\n        \"(node: Node = null) -\u003e void\", \n        method.signature.?\n    );\n}\n\ntest \"property signature with type\" {\n    const json = \\\\{\"name\": \"position\", \"type\": \"Vector2\"}\n    const property = try parseProperty(...);\n    try testing.expectEqualStrings(\": Vector2\", property.signature.?);\n}\n```\n\n## Acceptance Criteria\n\n- [ ] Methods have signatures: `(args) -\u003e ReturnType`\n- [ ] Properties have signatures: `: Type`\n- [ ] Constants have signatures: ` = value`\n- [ ] Signals have signatures: `(args)` if any\n- [ ] Global functions have signatures from return_type field\n- [ ] Default argument values included in signatures\n- [ ] Signatures display correctly in markdown output\n- [ ] Unit tests verify signature building","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-23T17:53:12.138889467+11:00","updated_at":"2025-11-23T17:53:12.138889467+11:00","source_repo":"."}
{"id":"gdoc-t91","content_hash":"148ddd85b484ab34e99ea6db340e5574865ccdac5519983a841c4514f913ae6f","title":"Fix panic on unknown JSON keys in parseMethod","description":"Similar to parseClass, parseMethod panics when encountering unknown JSON keys in method objects. This needs the same fix for robustness.","design":"## Problem\n\nLine 206 in DocDatabase.zig (approximately):\n```zig\nswitch (std.meta.stringToEnum(MethodKey, s) orelse std.debug.panic(\"Unexpected method key: {s}\", .{s})) {\n```\n\nThis panics on any unknown key in method objects.\n\n## Solution\n\nReplace panic with `continue`:\n\n```zig\nswitch (std.meta.stringToEnum(MethodKey, s) orelse continue) {\n```\n\n## Testing\n\nAdd test case with unknown method field to verify graceful skipping.","acceptance_criteria":"- [ ] Replace panic with continue in parseMethod\n- [ ] Add test case with unknown method field\n- [ ] Test passes without crashing","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-11-15T13:48:39.287104646+11:00","updated_at":"2025-11-23T00:13:07.653827303+11:00","closed_at":"2025-11-23T00:13:07.653827303+11:00","source_repo":"."}
{"id":"gdoc-vzr","content_hash":"e21e7f185dfa5a37d13527398eaf08eabfa90a76759012d57573b3ae158a7ca1","title":"Ensure --help and --version flags work correctly","description":"Verify that zli's auto-generated --help and --version flags work correctly with our CLI setup.","design":"## Auto-generated by zli\n\nThe zli framework automatically provides:\n- `--help` / `-h` flag\n- `--version` flag  \n- Auto-formatted help output\n- Usage line generation\n\n## What We Provide\n\nIn `buildCli()`, we already set:\n```zig\nconst root = try zli.Command.init(writer, reader, allocator, .{\n    .name = \"gdoc\",\n    .description = \"Godot API documentation viewer\",\n    .version = .{ .major = 0, .minor = 1, .patch = 0 },\n}, runLookup);\n```\n\n## Expected Behavior\n\n```bash\n$ gdoc --help\ngdoc - Godot API documentation viewer\n\nUsage: gdoc [options] \u003csymbol\u003e\n\nFlags:\n  --clear-cache    Clear cached API data before lookup\n  --godot \u003cpath\u003e   Path to Godot executable (default: 'godot' from PATH)\n  --help, -h       Show this help message\n  --version        Show version information\n\nArguments:\n  symbol           Symbol to look up (e.g. Node2D, Node2D.position)\n```\n\n```bash\n$ gdoc --version\ngdoc v0.1.0\n```\n\n## Testing Tasks\n\n- Verify `gdoc --help` shows formatted help\n- Verify `gdoc -h` works as shorthand\n- Verify `gdoc --version` shows version\n- Verify help includes all flags and arguments\n- Verify help output is properly aligned","acceptance_criteria":"- [ ] gdoc --help displays auto-generated help\n- [ ] gdoc -h works as shorthand\n- [ ] gdoc --version displays version\n- [ ] Help output includes all flags\n- [ ] Help output includes positional arguments\n- [ ] Help text is properly formatted and aligned","status":"open","priority":3,"issue_type":"task","created_at":"2025-11-14T16:08:21.333253+11:00","updated_at":"2025-11-14T16:08:21.333253+11:00","source_repo":".","dependencies":[{"issue_id":"gdoc-vzr","depends_on_id":"gdoc-zd9","type":"blocks","created_at":"2025-11-14T16:10:47.773664+11:00","created_by":"daemon"}]}
{"id":"gdoc-x3v","content_hash":"b669be8d1da31ae3ef64514a651cc46ede6d6b95b89c379a0a5045b56feff989","title":"Implement --complete flag for symbol prefix matching","description":"Add --complete flag that returns all symbols matching a given prefix, one per line. Foundation for shell completion scripts.","design":"## CLI Interface\n\n```bash\ngdoc --complete \"Node\"\n# Output (one per line):\nNode\nNode2D\nNode3D\nNodePath\n\ngdoc --complete \"Node2D.\"\n# Output:\nNode2D.position\nNode2D.rotation\nNode2D.scale\nNode2D.global_position\n...\n```\n\n## Implementation\n\n**Add flag to zli**:\n```zig\ntry root.addFlag(.{\n    .name = \"complete\",\n    .description = \"Return symbols matching prefix (for shell completion)\",\n    .type = .String,\n    .default_value = .{ .String = \"\" },\n});\n```\n\n**Update runLookup**:\n```zig\nfn runLookup(ctx: zli.CommandContext) !void {\n    const complete_prefix = ctx.flag(\"complete\", []const u8);\n    \n    if (complete_prefix.len \u003e 0) {\n        try gdoc.completeSymbol(complete_prefix, ctx.writer);\n        return;\n    }\n    \n    // ... rest of lookup logic\n}\n```\n\n**Implement completion logic** (in src/root.zig):\n```zig\npub fn completeSymbol(prefix: []const u8, writer: anytype) !void {\n    const db = try loadDatabase();\n    defer db.deinit();\n    \n    var matches = std.ArrayList([]const u8).init(db.allocator);\n    defer matches.deinit();\n    \n    // Iterate all symbols\n    var it = db.symbols.iterator();\n    while (it.next()) |entry| {\n        const key = entry.key_ptr.*;\n        if (std.mem.startsWith(u8, key, prefix)) {\n            try matches.append(key);\n        }\n    }\n    \n    // Sort alphabetically\n    std.mem.sort([]const u8, matches.items, {}, struct {\n        fn lessThan(_: void, a: []const u8, b: []const u8) bool {\n            return std.mem.lessThan(u8, a, b);\n        }\n    }.lessThan);\n    \n    // Output one per line\n    for (matches.items) |match| {\n        try writer.print(\"{s}\\n\", .{match});\n    }\n}\n```\n\n## Performance Consideration\n\n- Cache must be loaded for completion\n- First completion may be slow (cache generation)\n- Subsequent completions should be fast (binary cache)","acceptance_criteria":"- [ ] --complete flag accepts prefix string\n- [ ] Returns all symbols starting with prefix\n- [ ] Output is one symbol per line\n- [ ] Results are sorted alphabetically\n- [ ] Works with class names (e.g., \"Node\")\n- [ ] Works with member names (e.g., \"Node2D.\")\n- [ ] Handles empty prefix (returns all symbols)\n- [ ] Performance is acceptable for interactive use","status":"open","priority":3,"issue_type":"feature","created_at":"2025-11-14T16:08:58.899912+11:00","updated_at":"2025-11-14T16:08:58.899912+11:00","source_repo":".","dependencies":[{"issue_id":"gdoc-x3v","depends_on_id":"gdoc-42o","type":"blocks","created_at":"2025-11-14T16:08:58.901501+11:00","created_by":"daemon"},{"issue_id":"gdoc-x3v","depends_on_id":"gdoc-mqq","type":"blocks","created_at":"2025-11-14T16:10:47.999837+11:00","created_by":"daemon"}]}
{"id":"gdoc-ycj","content_hash":"31b091065dc5d3eb79d30c61495b72a2bafa62828246c640ced11eb9f9b3def8","title":"Add --godot-extension-api flag to load custom API JSON file","description":"Allow users to specify a custom path to an existing Godot extension_api.json file via CLI flag. This bypasses the cache system entirely and loads the API directly from the specified file.","design":"## Overview\n\nThe `--godot-extension-api` flag allows users to specify a custom path to an existing Godot extension_api.json file. When provided, this flag completely bypasses the cache system and loads the API data directly from the specified file.\n\n## CLI Interface \u0026 Flag Definition\n\nAdd a new string-type flag in `src/cli/root.zig`:\n\n```zig\n// In the build() function:\ntry root.addFlag(.{\n    .name = \"godot-extension-api\",\n    .description = \"Path to Godot extension_api.json file (bypasses cache)\",\n    .type = .String,\n    .default_value = null,  // Optional flag\n});\n```\n\n**User experience:**\n```bash\n# Use custom API file directly\ngdoc --godot-extension-api ~/godot/extension_api.json Node2D\n\n# Works with relative paths\ngdoc --godot-extension-api ./api.json Vector2\n\n# Clear error if file doesn't exist\ngdoc --godot-extension-api /bad/path.json Node2D\n# Error: API file not found: /bad/path.json\n```\n\n**Flag priority rules:**\n- If `--godot-extension-api` is provided, it takes complete precedence\n- The `--godot` flag is silently ignored when both are present\n- Cache system is completely bypassed (no reading, no writing)\n\n## Integration with Lookup Flow\n\nUpdate `runLookup()` in `src/cli/root.zig`:\n\n```zig\nfn runLookup(ctx: CommandContext) !void {\n    const clear_cache = ctx.flag(\"clear-cache\", bool);\n    const api_json_path = ctx.flag(\"godot-extension-api\", ?[]const u8);\n\n    // print help when no arguments/flags are provided\n    if (!clear_cache and ctx.positional_args.len == 0 and api_json_path == null) {\n        try ctx.command.printHelp();\n        return;\n    }\n\n    if (clear_cache) {\n        try gdoc.cache.clearCache(ctx.allocator);\n        try ctx.writer.writeAll(\"Cache cleared.\\n\");\n    }\n\n    const symbol = ctx.getArg(\"symbol\") orelse return;\n    \n    // Pass allocator and api_json_path to lookup function\n    gdoc.lookupAndDisplay(ctx.allocator, symbol, api_json_path, ctx.writer) catch |err| switch (err) {\n        error.SymbolNotFound =\u003e \n            try ctx.writer.print(\"Symbol '{s}' not found.\\n\", .{symbol}),\n        error.ApiFileNotFound =\u003e \n            try ctx.writer.print(\"Error: API file not found: {s}\\n\", .{api_json_path.?}),\n        error.InvalidApiJson =\u003e \n            try ctx.writer.print(\"Error: Invalid JSON in API file: {s}\\n\", .{api_json_path.?}),\n        else =\u003e return err,\n    };\n\n    try ctx.writer.flush();\n}\n```\n\n**Key changes:**\n- Extract `api_json_path` from flags (nullable)\n- Pass allocator and api_json_path to `lookupAndDisplay`\n- Add error handling for `ApiFileNotFound` and `InvalidApiJson`\n- Update help condition to check for the new flag\n\n## Core Library Changes (src/root.zig)\n\nUpdate `lookupAndDisplay()` signature:\n\n```zig\npub const LookupError = error{\n    ApiFileNotFound,      // New: --godot-extension-api file doesn't exist\n} || Writer.Error || DocDatabase.Error;\n\npub fn lookupAndDisplay(\n    allocator: Allocator,\n    symbol: []const u8, \n    api_json_path: ?[]const u8,\n    writer: *Writer\n) LookupError!void {\n    // Load database based on api_json_path\n    const db = if (api_json_path) |path|\n        try loadFromApiFile(allocator, path)\n    else\n        try loadFromCacheOrGenerate(allocator);\n    \n    // Perform lookup and display\n    const entry = db.lookup(symbol) orelse return error.SymbolNotFound;\n    try displayEntry(entry, writer);\n}\n```\n\n**Two separate loading paths:**\n\n1. **When `--godot-extension-api` is provided:** Call `loadFromApiFile()`\n   - Validates file exists\n   - Reads JSON directly\n   - Parses into DocDatabase\n   - Never touches cache\n\n2. **Normal flow (no flag):** Call `loadFromCacheOrGenerate()`\n   - Existing logic: check parsed cache → JSON cache → generate from Godot\n   - Uses the existing `api.loadOrGenerateCache()` function\n\n## New API Loading Function\n\nAdd `loadFromApiFile()` in `src/root.zig`:\n\n```zig\nfn loadFromApiFile(allocator: Allocator, api_path: []const u8) !DocDatabase {\n    // Validate file exists\n    const file = std.fs.openFileAbsolute(api_path, .{}) catch |err| switch (err) {\n        error.FileNotFound =\u003e return error.ApiFileNotFound,\n        else =\u003e return err,\n    };\n    defer file.close();\n    \n    // Parse JSON directly into DocDatabase\n    var arena = std.heap.ArenaAllocator.init(allocator);\n    errdefer arena.deinit();\n    \n    const db = DocDatabase.loadFromJsonFileLeaky(arena.allocator(), file) catch |err| switch (err) {\n        error.SyntaxError, error.UnexpectedToken =\u003e return error.InvalidApiJson,\n        else =\u003e return err,\n    };\n    \n    return db;\n}\n\nfn loadFromCacheOrGenerate(allocator: Allocator) !DocDatabase {\n    // Existing cache logic - will be implemented later\n    // For now, this is a placeholder for the normal flow\n    _ = allocator;\n    return error.NotImplemented;\n}\n```\n\n**Key behaviors:**\n- Opens file as absolute path (supports both relative and absolute paths via std.fs)\n- Returns `ApiFileNotFound` if file doesn't exist\n- Returns `InvalidApiJson` if JSON parsing fails\n- Uses arena allocator for the DocDatabase (leaky pattern, cleaned up by caller)\n- No cache interaction whatsoever\n\n## Error Handling Updates\n\nAdd new error type to `DocDatabase.Error` in `src/DocDatabase.zig`:\n\n```zig\npub const Error = error{\n    SymbolNotFound,\n    InvalidApiJson,       // New: JSON parsing failed for provided file\n    // ... (other existing errors)\n};\n```\n\nAdd `ApiFileNotFound` to `LookupError` in `src/root.zig`:\n\n```zig\npub const LookupError = error{\n    ApiFileNotFound,      // New: --godot-extension-api file doesn't exist\n} || Writer.Error || DocDatabase.Error;\n```\n\n**Error flow:**\n\n1. **ApiFileNotFound** - Thrown from `loadFromApiFile()` in `src/root.zig`:\n   - User provides `--godot-extension-api /path/to/file.json`\n   - File doesn't exist at that path\n   - Message: `Error: API file not found: /path/to/file.json`\n\n2. **InvalidApiJson** - Thrown from `DocDatabase.loadFromJsonFileLeaky()`:\n   - File exists but contains invalid JSON\n   - JSON is valid but doesn't match expected schema\n   - Message: `Error: Invalid JSON in API file: /path/to/file.json`\n\n3. **SymbolNotFound** - Existing `DocDatabase.Error`:\n   - Symbol lookup fails in the database\n   - Message: `Symbol 'Foo' not found.`\n\n## Testing Strategy\n\nAdd tests to `src/root.zig`:\n\n```zig\ntest \"lookupAndDisplay loads from custom API file when provided\" {\n    const allocator = std.testing.allocator;\n    \n    // Create temporary API JSON file\n    var tmp_dir = std.testing.tmpDir(.{});\n    defer tmp_dir.cleanup();\n    \n    const tmp_path = try tmp_dir.dir.realpathAlloc(allocator, \".\");\n    defer allocator.free(tmp_path);\n    \n    const api_path = try std.fmt.allocPrint(allocator, \"{s}/test_api.json\", .{tmp_path});\n    defer allocator.free(api_path);\n    \n    // Write minimal valid API JSON\n    const test_json = \n        \\\\{\"builtin_classes\": [{\"name\": \"TestClass\", \"methods\": []}]}\n    ;\n    try std.fs.cwd().writeFile(.{ .sub_path = api_path, .data = test_json });\n    \n    // Call lookupAndDisplay with custom API path\n    var output = std.ArrayList(u8).init(allocator);\n    defer output.deinit();\n    var writer = output.writer();\n    \n    // Should load from the custom file (not cache)\n    const result = lookupAndDisplay(allocator, \"TestClass\", api_path, \u0026writer);\n    \n    // Verify it loaded successfully\n    try std.testing.expect(result != error.ApiFileNotFound);\n}\n\ntest \"lookupAndDisplay returns ApiFileNotFound for nonexistent file\" {\n    const allocator = std.testing.allocator;\n    \n    var output = std.ArrayList(u8).init(allocator);\n    defer output.deinit();\n    var writer = output.writer();\n    \n    const result = lookupAndDisplay(allocator, \"Node2D\", \"/nonexistent/api.json\", \u0026writer);\n    \n    try std.testing.expectError(error.ApiFileNotFound, result);\n}\n\ntest \"lookupAndDisplay returns InvalidApiJson for malformed JSON\" {\n    const allocator = std.testing.allocator;\n    \n    var tmp_dir = std.testing.tmpDir(.{});\n    defer tmp_dir.cleanup();\n    \n    const tmp_path = try tmp_dir.dir.realpathAlloc(allocator, \".\");\n    defer allocator.free(tmp_path);\n    \n    const api_path = try std.fmt.allocPrint(allocator, \"{s}/bad_api.json\", .{tmp_path});\n    defer allocator.free(api_path);\n    \n    // Write invalid JSON\n    try std.fs.cwd().writeFile(.{ .sub_path = api_path, .data = \"{ invalid json\" });\n    \n    var output = std.ArrayList(u8).init(allocator);\n    defer output.deinit();\n    var writer = output.writer();\n    \n    const result = lookupAndDisplay(allocator, \"Node2D\", api_path, \u0026writer);\n    \n    try std.testing.expectError(error.InvalidApiJson, result);\n}\n```\n\n**Test coverage:**\n- Custom API file loads successfully\n- Nonexistent file returns `ApiFileNotFound`\n- Invalid JSON returns `InvalidApiJson`\n- Cache is bypassed when flag is used (verified by file isolation in tmp dir)\n\n## Acceptance Criteria\n\n- --godot-extension-api flag added to CLI\n- Flag accepts file path (relative or absolute)\n- When flag is provided, cache is completely bypassed\n- File existence is validated before opening\n- ApiFileNotFound error returned for missing files\n- InvalidApiJson error returned for malformed JSON\n- When both --godot and --godot-extension-api are provided, --godot-extension-api takes priority silently\n- Friendly error messages for expected errors\n- Tests verify custom API file loading\n- Tests verify ApiFileNotFound error handling\n- Tests verify InvalidApiJson error handling","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-11-22T10:37:12.419359735+11:00","updated_at":"2025-11-22T11:19:09.551594086+11:00","closed_at":"2025-11-22T11:19:09.551594086+11:00","source_repo":"."}
{"id":"gdoc-zd9","content_hash":"9ffe5e4a3f02da4d1e64f372b6756a5eaa40896a844c18b74a842a9ec9f27d9c","title":"Implement CLI argument parsing with zli","description":"Implement command-line interface using zli v4.3.0 for parsing symbol lookups and --clear-cache flag.","design":"## Project Structure\n\nFollowing zli's recommended layout, keeping it simple (YAGNI):\n\n```\nsrc/\n├── main.zig          # Minimal entry point\n├── root.zig          # Core gdoc library (existing)\n└── cli/\n    └── root.zig      # All CLI logic (no subcommands needed)\n```\n\n## CLI Interface\n\n```bash\ngdoc                          # Shows help\ngdoc Node2D                   # Looks up Node2D\ngdoc --clear-cache            # Clears cache, shows success message, exits\ngdoc --clear-cache Node2D     # Clears cache, then looks up Node2D\ngdoc --help                   # Auto-generated help\ngdoc --version                # Auto-generated version\n```\n\n## Implementation\n\n### src/main.zig\n\nMinimal entry point following zli pattern:\n\n```zig\nconst std = @import(\"std\");\nconst cli = @import(\"cli/root.zig\");\n\npub fn main() !void {\n    var dbg = std.heap.DebugAllocator(.{}).init;\n    \n    const allocator = switch (@import(\"builtin\").mode) {\n        .Debug =\u003e dbg.allocator(),\n        .ReleaseFast, .ReleaseSafe, .ReleaseSmall =\u003e std.heap.smp_allocator,\n    };\n    \n    defer if (@import(\"builtin\").mode == .Debug) {\n        std.debug.assert(dbg.deinit() == .ok);\n    };\n\n    var stdout_writer = std.fs.File.stdout().writerStreaming(\u0026.{});\n    var stdout = \u0026stdout_writer.interface;\n    \n    var buf: [4096]u8 = undefined;\n    var stdin_reader = std.fs.File.stdin().readerStreaming(\u0026buf);\n    const stdin = \u0026stdin_reader.interface;\n\n    const root = try cli.build(stdout, stdin, allocator);\n    defer root.deinit();\n\n    try root.execute(.{});\n    try stdout_writer.flush();\n}\n\n// Minimal smoke test\ntest \"CLI integration compiles\" {\n    // Test will pass once basic structure compiles with zli\n    @panic(\"CLI integration not implemented - RED phase\");\n}\n```\n\n### src/cli/root.zig\n\nAll CLI logic in one file:\n\n```zig\nconst std = @import(\"std\");\nconst Writer = std.Io.Writer;\nconst Reader = std.Io.Reader;\nconst zli = @import(\"zli\");\nconst gdoc = @import(\"gdoc\");\n\npub fn build(writer: *Writer, reader: *Reader, allocator: std.mem.Allocator) !*zli.Command {\n    const root = try zli.Command.init(writer, reader, allocator, .{\n        .name = \"gdoc\",\n        .description = \"Godot API documentation viewer\",\n        .version = .{ .major = 0, .minor = 1, .patch = 0 },\n    }, runLookup);\n\n    try root.addFlag(.{\n        .name = \"clear-cache\",\n        .description = \"Clear cached API data before lookup\",\n        .type = .Bool,\n        .default_value = .{ .Bool = false },\n    });\n\n    try root.addPositionalArg(.{\n        .name = \"symbol\",\n        .description = \"Symbol to look up (e.g. Node2D, Node2D.position)\",\n        .required = false,\n    });\n\n    return root;\n}\n\nfn runLookup(ctx: zli.CommandContext) !void {\n    const clear_cache = ctx.flag(\"clear-cache\", bool);\n    const symbol = ctx.getArg(\"symbol\");\n    \n    // Handle --clear-cache flag\n    if (clear_cache) {\n        try gdoc.clearCache();\n        try ctx.writer.print(\"Cache cleared.\\n\", .{});\n    }\n    \n    // If no symbol provided\n    if (symbol == null) {\n        if (!clear_cache) {\n            // No symbol, no clear-cache → show help\n            try ctx.command.printHelp();\n        }\n        // Symbol not provided but cache was cleared → exit cleanly\n        return;\n    }\n    \n    // Lookup symbol with error handling\n    gdoc.lookupAndDisplay(symbol.?, ctx.writer) catch |err| switch (err) {\n        error.SymbolNotFound =\u003e {\n            try ctx.writer.print(\"Symbol '{s}' not found\\n\", .{symbol.?});\n            return;\n        },\n        // Let unexpected errors bubble up for stack trace\n        else =\u003e return err,\n    };\n}\n```\n\n### Stub for GREEN Phase\n\nIn `src/root.zig`, add minimal stub:\n\n```zig\npub fn lookupAndDisplay(symbol: []const u8, writer: anytype) !void {\n    try writer.print(\"Lookup not yet implemented for symbol: {s}\\n\", .{symbol});\n}\n```\n\n### build.zig Changes\n\nAdd zli module import:\n\n```zig\nconst zli = b.dependency(\"zli\", .{\n    .target = target,\n    .optimize = optimize,\n}).module(\"zli\");\n\n// In exe.root_module.imports:\n.imports = \u0026.{\n    .{ .name = \"gdoc\", .module = mod },\n    .{ .name = \"zli\", .module = zli },\n},\n```\n\n## Error Handling Strategy\n\n**Expected errors** (friendly messages):\n- Symbol not found → \"Symbol 'Foo' not found\"\n\n**Unexpected errors** (stack traces for debugging):\n- I/O failures, cache corruption, etc.\n\n## Auto-generated by zli\n\n- `--help` / `-h` flag with formatted output\n- `--version` flag\n- Aligned flag descriptions\n- Usage line generation\n\n## Dependencies\n\nAlready in `build.zig.zon`:\n- zli v4.3.0 ✓\n\n## Notes\n\n- Using `std.heap.DebugAllocator` (not deprecated `GeneralPurposeAllocator`)\n- Debug allocator checks optimized away in release builds\n- `gdoc.clearCache()` already implemented (gdoc-2id)\n- `gdoc.lookupAndDisplay()` is stub for GREEN phase","acceptance_criteria":"- [ ] zli v4.3.0 added as dependency in build.zig.zon\n- [ ] zli module imported in build.zig\n- [ ] CLI accepts symbol as positional argument\n- [ ] --clear-cache flag implemented\n- [ ] --help shows auto-generated help\n- [ ] --version shows version info\n- [ ] No symbol provided shows help message\n- [ ] Integrates with gdoc.lookupAndDisplay() function","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-11-14T16:07:19.633866+11:00","updated_at":"2025-11-16T14:40:26.707948696+11:00","closed_at":"2025-11-16T14:40:26.707948696+11:00","source_repo":".","dependencies":[{"issue_id":"gdoc-zd9","depends_on_id":"gdoc-2id","type":"blocks","created_at":"2025-11-14T16:10:47.492752+11:00","created_by":"daemon"},{"issue_id":"gdoc-zd9","depends_on_id":"gdoc-mqq","type":"blocks","created_at":"2025-11-14T16:10:47.562234+11:00","created_by":"daemon"}]}
